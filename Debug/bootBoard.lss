
bootBoard.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000790  00020000  00020000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .BOOT         0000003a  00020790  00020790  00000804  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         00000000  00802000  00802000  0000083e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000001  00802000  00802000  0000083e  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  0000083e  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000870  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000000d8  00000000  00000000  000008b0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00004a4e  00000000  00000000  00000988  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000367b  00000000  00000000  000053d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000d52  00000000  00000000  00008a51  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000250  00000000  00000000  000097a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00002de5  00000000  00000000  000099f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000ba8  00000000  00000000  0000c7d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000108  00000000  00000000  0000d388  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00020000 <__vectors>:
   20000:	0d 94 fa 00 	jmp	0x201f4	; 0x201f4 <__ctors_end>
   20004:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20008:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2000c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20010:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20014:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20018:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2001c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20020:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20024:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20028:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2002c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20030:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20034:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20038:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2003c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20040:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20044:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20048:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2004c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20050:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20054:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20058:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2005c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20060:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20064:	0d 94 c9 02 	jmp	0x20592	; 0x20592 <__vector_25>
   20068:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2006c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20070:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20074:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20078:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2007c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20080:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20084:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20088:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2008c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20090:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20094:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20098:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2009c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200a0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200a4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200a8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200ac:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200b0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200b4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200b8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200bc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200c0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200c4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200c8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200cc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200d0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200d4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200d8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200dc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200e0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200e4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200e8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200ec:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200f0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200f4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200f8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200fc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20100:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20104:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20108:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2010c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20110:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20114:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20118:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2011c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20120:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20124:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20128:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2012c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20130:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20134:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20138:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2013c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20140:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20144:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20148:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2014c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20150:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20154:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20158:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2015c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20160:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20164:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20168:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2016c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20170:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20174:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20178:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2017c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20180:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20184:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20188:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2018c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20190:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20194:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20198:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2019c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201a0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201a4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201a8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201ac:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201b0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201b4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201b8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201bc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201c0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201c4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201c8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201cc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201d0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201d4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201d8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201dc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201e0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201e4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201e8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201ec:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201f0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>

000201f4 <__ctors_end>:
   201f4:	11 24       	eor	r1, r1
   201f6:	1f be       	out	0x3f, r1	; 63
   201f8:	cf ef       	ldi	r28, 0xFF	; 255
   201fa:	cd bf       	out	0x3d, r28	; 61
   201fc:	df e3       	ldi	r29, 0x3F	; 63
   201fe:	de bf       	out	0x3e, r29	; 62
   20200:	01 e0       	ldi	r16, 0x01	; 1
   20202:	0c bf       	out	0x3c, r16	; 60
   20204:	18 be       	out	0x38, r1	; 56
   20206:	19 be       	out	0x39, r1	; 57
   20208:	1a be       	out	0x3a, r1	; 58
   2020a:	1b be       	out	0x3b, r1	; 59

0002020c <__do_clear_bss>:
   2020c:	20 e2       	ldi	r18, 0x20	; 32
   2020e:	a0 e0       	ldi	r26, 0x00	; 0
   20210:	b0 e2       	ldi	r27, 0x20	; 32
   20212:	01 c0       	rjmp	.+2      	; 0x20216 <.do_clear_bss_start>

00020214 <.do_clear_bss_loop>:
   20214:	1d 92       	st	X+, r1

00020216 <.do_clear_bss_start>:
   20216:	a1 30       	cpi	r26, 0x01	; 1
   20218:	b2 07       	cpc	r27, r18
   2021a:	e1 f7       	brne	.-8      	; 0x20214 <.do_clear_bss_loop>
   2021c:	0f 94 5e 02 	call	0x204bc	; 0x204bc <main>
   20220:	0d 94 c6 03 	jmp	0x2078c	; 0x2078c <_exit>

00020224 <__bad_interrupt>:
   20224:	0d 94 00 00 	jmp	0x20000	; 0x20000 <__vectors>

00020228 <SP_ReadByte>:

.section .text
.global SP_ReadByte

SP_ReadByte:
	in	r19, RAMPZ      ; Save RAMPZ.
   20228:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
   2022a:	8b bf       	out	0x3b, r24	; 59
	movw	ZL, r22         ; Move the low bytes to the Z pointer
   2022c:	fb 01       	movw	r30, r22
	elpm	r24, Z          ; Extended load byte from address pointed to by Z.
   2022e:	86 91       	elpm	r24, Z
	out	RAMPZ, r19      ; Restore RAMPZ register.
   20230:	3b bf       	out	0x3b, r19	; 59
	ret
   20232:	08 95       	ret

00020234 <SP_ReadWord>:

.section .text
.global SP_ReadWord

SP_ReadWord:
	in	r19, RAMPZ      ; Save RAMPZ.
   20234:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
   20236:	8b bf       	out	0x3b, r24	; 59
	movw	ZL, r22         ; Move the low bytes to the Z pointer
   20238:	fb 01       	movw	r30, r22
	elpm	r24, Z+         ; Extended load byte from address pointed to by Z.
   2023a:	87 91       	elpm	r24, Z+
	elpm	r25, Z          ; Extended load byte from address pointed to by Z.
   2023c:	96 91       	elpm	r25, Z
	out	RAMPZ, r19      ; Restore RAMPZ register.
   2023e:	3b bf       	out	0x3b, r19	; 59
	ret
   20240:	08 95       	ret

00020242 <SP_ReadCalibrationByte>:

.section .text
.global SP_ReadCalibrationByte	

SP_ReadCalibrationByte:
	ldi	r20, NVM_CMD_READ_CALIB_ROW_gc    ; Prepare NVM command in R20.
   20242:	42 e0       	ldi	r20, 0x02	; 2
	rjmp	SP_CommonLPM                      ; Jump to common LPM code.
   20244:	81 c0       	rjmp	.+258    	; 0x20348 <SP_CommonLPM>

00020246 <SP_ReadUserSignatureByte>:

.section .text	
.global SP_ReadUserSignatureByte

SP_ReadUserSignatureByte:
	ldi	r20, NVM_CMD_READ_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
   20246:	41 e0       	ldi	r20, 0x01	; 1
	rjmp	SP_CommonLPM                       ; Jump to common LPM code.
   20248:	7f c0       	rjmp	.+254    	; 0x20348 <SP_CommonLPM>

0002024a <SP_ReadFuseByte>:

.section .text	
.global SP_ReadFuseByte

SP_ReadFuseByte:
	sts	NVM_ADDR0, r24              ; Load fuse byte index into NVM Address Register 0.
   2024a:	80 93 c0 01 	sts	0x01C0, r24	; 0x8001c0 <__TEXT_REGION_LENGTH__+0x7001c0>
	clr	r24                         ; Prepare a zero.
   2024e:	88 27       	eor	r24, r24
	sts	NVM_ADDR1, r24              ; Load zero into NVM Address Register 1.
   20250:	80 93 c1 01 	sts	0x01C1, r24	; 0x8001c1 <__TEXT_REGION_LENGTH__+0x7001c1>
	sts	NVM_ADDR2, r24              ; Load zero into NVM Address Register 2.
   20254:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <__TEXT_REGION_LENGTH__+0x7001c2>
	ldi	r20, NVM_CMD_READ_FUSES_gc  ; Prepare NVM command in R20.
   20258:	47 e0       	ldi	r20, 0x07	; 7
	rcall	SP_CommonCMD                ; Jump to common NVM Action code.
   2025a:	66 d0       	rcall	.+204    	; 0x20328 <SP_CommonCMD>
	movw	r24, r22                    ; Move low byte to 1 byte return address.
   2025c:	cb 01       	movw	r24, r22
	ret
   2025e:	08 95       	ret

00020260 <SP_WriteLockBits>:

.section .text	
.global SP_WriteLockBits

SP_WriteLockBits:
	sts	NVM_DATA0, r24                  ; Load lock bits into NVM Data Register 0.
   20260:	80 93 c4 01 	sts	0x01C4, r24	; 0x8001c4 <__TEXT_REGION_LENGTH__+0x7001c4>
	ldi	r20, NVM_CMD_WRITE_LOCK_BITS_gc ; Prepare NVM command in R20.
   20264:	48 e0       	ldi	r20, 0x08	; 8
	rjmp	SP_CommonCMD                    ; Jump to common NVM Action code.
   20266:	60 c0       	rjmp	.+192    	; 0x20328 <SP_CommonCMD>

00020268 <SP_ReadLockBits>:

.section .text		
.global SP_ReadLockBits

SP_ReadLockBits:
	lds	r24, NVM_LOCKBITS       ; Read IO-mapped lock bits.
   20268:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <__TEXT_REGION_LENGTH__+0x7001d0>
	ret
   2026c:	08 95       	ret

0002026e <SP_EraseUserSignatureRow>:

.section .text
.global SP_EraseUserSignatureRow

SP_EraseUserSignatureRow:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   2026e:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_USER_SIG_ROW_gc ; Prepare NVM command in R20.
   20270:	48 e1       	ldi	r20, 0x18	; 24
	jmp 	SP_CommonSPM                       ; Jump to common SPM code.
   20272:	0d 94 db 03 	jmp	0x207b6	; 0x207b6 <SP_CommonSPM>

00020276 <SP_WriteUserSignatureRow>:

.section .text
.global SP_WriteUserSignatureRow

SP_WriteUserSignatureRow:
	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
   20276:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_WRITE_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
   20278:	4a e1       	ldi	r20, 0x1A	; 26
	jmp	SP_CommonSPM                        ; Jump to common SPM code.
   2027a:	0d 94 db 03 	jmp	0x207b6	; 0x207b6 <SP_CommonSPM>

0002027e <SP_EraseApplicationSection>:

.section .text
.global SP_EraseApplicationSection

SP_EraseApplicationSection:
	in	r19, RAMPZ                 ; Save RAMPZ, which is restored in SP_CommonSPM.
   2027e:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_APP_gc  ; Prepare NVM command in R20.
   20280:	40 e2       	ldi	r20, 0x20	; 32
	jmp	SP_CommonSPM               ; Jump to common SPM code.
   20282:	0d 94 db 03 	jmp	0x207b6	; 0x207b6 <SP_CommonSPM>

00020286 <SP_EraseApplicationPage>:

.section .text	
.global SP_EraseApplicationPage

SP_EraseApplicationPage:
	in	r19, RAMPZ                      ; Save RAMPZ, which is restored in SP_CommonSPM.
   20286:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                      ; Load RAMPZ with the MSB of the address.
   20288:	8b bf       	out	0x3b, r24	; 59
	movw    r24, r22                        ; Move low bytes for ZH:ZL to R25:R24
   2028a:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_APP_PAGE_gc  ; Prepare NVM command in R20.
   2028c:	42 e2       	ldi	r20, 0x22	; 34
	jmp	SP_CommonSPM                    ; Jump to common SPM code.
   2028e:	0d 94 db 03 	jmp	0x207b6	; 0x207b6 <SP_CommonSPM>

00020292 <SP_LoadFlashWord>:

.section .text
.global SP_LoadFlashWord

SP_LoadFlashWord:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   20292:	3b b7       	in	r19, 0x3b	; 59
	movw	r0, r22                            ; Prepare flash word in R1:R0.
   20294:	0b 01       	movw	r0, r22
	ldi	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
   20296:	43 e2       	ldi	r20, 0x23	; 35
	jmp	SP_CommonSPM                       ; Jump to common SPM code.
   20298:	0d 94 db 03 	jmp	0x207b6	; 0x207b6 <SP_CommonSPM>

0002029c <SP_ReadFlashPage>:
.section .text		
.global SP_ReadFlashPage

SP_ReadFlashPage:

	in	r19, RAMPZ                   ; Save RAMPZ during assembly.
   2029c:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r22                   ; Load RAMPZ with MSB of address
   2029e:	6b bf       	out	0x3b, r22	; 59
	movw    ZL, r20                      ; Load Z with Flash address.
   202a0:	fa 01       	movw	r30, r20

	out	RAMPX, r1                    ; Load RAMPX with data pointer
   202a2:	19 be       	out	0x39, r1	; 57
	movw	XL, r24                      ; Load X with data buffer address.
   202a4:	dc 01       	movw	r26, r24

	ldi	r20, NVM_CMD_NO_OPERATION_gc ; Prepare NVM command code in R20.
   202a6:	40 e0       	ldi	r20, 0x00	; 0
	sts	NVM_CMD, r20                 ; Set NVM command to No Operation so that LPM reads Flash.
   202a8:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>

#if FLASH_PAGE_SIZE > 512
	ldi	r22, ((FLASH_PAGE_SIZE/2) >> 8) ; Load R22 with byte cont high if flash page is large.
#endif	

	ldi	r21, ((FLASH_PAGE_SIZE)&0xFF)   ; Load R21 with byte count.
   202ac:	50 e0       	ldi	r21, 0x00	; 0

000202ae <SP_ReadFlashPage_1>:

SP_ReadFlashPage_1:
	elpm	r24, Z+                         ; Load Flash bytes into R18:r19
   202ae:	87 91       	elpm	r24, Z+
	elpm	r25, Z+
   202b0:	97 91       	elpm	r25, Z+
	st	X+, r24                         ; Write bytes to buffer.
   202b2:	8d 93       	st	X+, r24
	st	X+, r25
   202b4:	9d 93       	st	X+, r25

#if FLASH_PAGE_SIZE > 512
	subi	r21, 1                          ; Decrement word count.
	sbci	r22, 0
#else
	dec	r21                             ; Decrement word count.
   202b6:	5a 95       	dec	r21
#endif	

	brne	SP_ReadFlashPage_1              ; Repeat until byte count is zero.
   202b8:	d1 f7       	brne	.-12     	; 0x202ae <SP_ReadFlashPage_1>

	out	RAMPZ, r19
   202ba:	3b bf       	out	0x3b, r19	; 59
	ret
   202bc:	08 95       	ret

000202be <SP_WriteApplicationPage>:

.section .text		
.global SP_WriteApplicationPage

SP_WriteApplicationPage:
	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
   202be:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
   202c0:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
   202c2:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_WRITE_APP_PAGE_gc   ; Prepare NVM command in R20.
   202c4:	44 e2       	ldi	r20, 0x24	; 36
	jmp	SP_CommonSPM                     ; Jump to common SPM code.
   202c6:	0d 94 db 03 	jmp	0x207b6	; 0x207b6 <SP_CommonSPM>

000202ca <SP_EraseWriteApplicationPage>:

.section .text
.global SP_EraseWriteApplicationPage

SP_EraseWriteApplicationPage:
	in	r19, RAMPZ                            ; Save RAMPZ, which is restored in SP_CommonSPM.
   202ca:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                            ; Load RAMPZ with the MSB of the address.
   202cc:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                              ; Move low bytes of address to ZH:ZL from R23:R22
   202ce:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_WRITE_APP_PAGE_gc  ; Prepare NVM command in R20.
   202d0:	45 e2       	ldi	r20, 0x25	; 37
	jmp	SP_CommonSPM                          ; Jump to common SPM code.
   202d2:	0d 94 db 03 	jmp	0x207b6	; 0x207b6 <SP_CommonSPM>

000202d6 <SP_EraseFlashBuffer>:

.section .text		
.global SP_EraseFlashBuffer

SP_EraseFlashBuffer:
	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
   202d6:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
   202d8:	46 e2       	ldi	r20, 0x26	; 38
	jmp	SP_CommonSPM                        ; Jump to common SPM code.
   202da:	0d 94 db 03 	jmp	0x207b6	; 0x207b6 <SP_CommonSPM>

000202de <SP_EraseBootPage>:

.section .text		
.global SP_EraseBootPage

SP_EraseBootPage:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   202de:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                         ; Load RAMPZ with the MSB of the address.
   202e0:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                           ; Move low bytes of address to ZH:ZL from R23:R22
   202e2:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_BOOT_PAGE_gc    ; Prepare NVM command in R20.
   202e4:	4a e2       	ldi	r20, 0x2A	; 42
	jmp	SP_CommonSPM                       ; Jump to common SPM code.
   202e6:	0d 94 db 03 	jmp	0x207b6	; 0x207b6 <SP_CommonSPM>

000202ea <SP_WriteBootPage>:

.section .text		
.global SP_WriteBootPage

SP_WriteBootPage:
	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
   202ea:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
   202ec:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
   202ee:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
   202f0:	4c e2       	ldi	r20, 0x2C	; 44
	jmp	SP_CommonSPM                     ; Jump to common SPM code.
   202f2:	0d 94 db 03 	jmp	0x207b6	; 0x207b6 <SP_CommonSPM>

000202f6 <SP_EraseWriteBootPage>:

.section .text		
.global SP_EraseWriteBootPage

SP_EraseWriteBootPage:
	in	r19, RAMPZ                             ; Save RAMPZ, which is restored in SP_CommonSPM.
   202f6:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                             ; Load RAMPZ with the MSB of the address.
   202f8:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                               ; Move low bytes of address to ZH:ZL from R23:R22
   202fa:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
   202fc:	4d e2       	ldi	r20, 0x2D	; 45
	jmp	SP_CommonSPM                           ; Jump to common SPM code.
   202fe:	0d 94 db 03 	jmp	0x207b6	; 0x207b6 <SP_CommonSPM>

00020302 <SP_ApplicationCRC>:

.section .text	
.global SP_ApplicationCRC

SP_ApplicationCRC:
	ldi	r20, NVM_CMD_APP_CRC_gc    ; Prepare NVM command in R20.
   20302:	48 e3       	ldi	r20, 0x38	; 56
	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
   20304:	11 c0       	rjmp	.+34     	; 0x20328 <SP_CommonCMD>

00020306 <SP_BootCRC>:

.section .text
.global SP_BootCRC

SP_BootCRC:
	ldi	r20, NVM_CMD_BOOT_CRC_gc   ; Prepare NVM command in R20.
   20306:	49 e3       	ldi	r20, 0x39	; 57
	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
   20308:	0f c0       	rjmp	.+30     	; 0x20328 <SP_CommonCMD>

0002030a <SP_LockSPM>:

.section .text
.global SP_LockSPM

SP_LockSPM:
	ldi	r18, CCP_IOREG_gc     ; Prepare Protect IO-register signature in R18.
   2030a:	28 ed       	ldi	r18, 0xD8	; 216
	sts	CCP, r18              ; Enable IO-register operation (this disables interrupts for 4 cycles).
   2030c:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	ldi	r18, NVM_SPMLOCK_bm   ; Prepare bitmask for locking SPM into R18.
   20310:	21 e0       	ldi	r18, 0x01	; 1
	sts	NVM_CTRLB, r18        ; Load bitmask into NVM Control Register B, which locks SPM.
   20312:	20 93 cc 01 	sts	0x01CC, r18	; 0x8001cc <__TEXT_REGION_LENGTH__+0x7001cc>
	ret
   20316:	08 95       	ret

00020318 <SP_WaitForSPM>:

.section .text
.global SP_WaitForSPM		

SP_WaitForSPM:
	lds	r18, NVM_STATUS     ; Load the NVM Status register.
   20318:	20 91 cf 01 	lds	r18, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7001cf>
	sbrc	r18, NVM_NVMBUSY_bp ; Check if bit is cleared.
   2031c:	27 fd       	sbrc	r18, 7
	rjmp	SP_WaitForSPM       ; Repeat check if bit is not cleared.
   2031e:	fc cf       	rjmp	.-8      	; 0x20318 <SP_WaitForSPM>
	clr	r18
   20320:	22 27       	eor	r18, r18
	sts	NVM_CMD, r18        ; Clear up command register to NO_OPERATION.
   20322:	20 93 ca 01 	sts	0x01CA, r18	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	ret
   20326:	08 95       	ret

00020328 <SP_CommonCMD>:
; ---

.section .text		

SP_CommonCMD:
	sts	NVM_CMD, r20        ; Load command into NVM Command register.
   20328:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	ldi	r18, CCP_IOREG_gc   ; Prepare Protect IO-register signature in R18.
   2032c:	28 ed       	ldi	r18, 0xD8	; 216
	ldi	r19, NVM_CMDEX_bm   ; Prepare bitmask for setting NVM Command Execute bit into R19.
   2032e:	31 e0       	ldi	r19, 0x01	; 1
	sts	CCP, r18            ; Enable IO-register operation (this disables interrupts for 4 cycles).
   20330:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	sts	NVM_CTRLA, r19      ; Load bitmask into NVM Control Register A, which executes the command.
   20334:	30 93 cb 01 	sts	0x01CB, r19	; 0x8001cb <__TEXT_REGION_LENGTH__+0x7001cb>
	lds	r22, NVM_DATA0      ; Load NVM Data Register 0 into R22.
   20338:	60 91 c4 01 	lds	r22, 0x01C4	; 0x8001c4 <__TEXT_REGION_LENGTH__+0x7001c4>
	lds	r23, NVM_DATA1      ; Load NVM Data Register 1 into R23.
   2033c:	70 91 c5 01 	lds	r23, 0x01C5	; 0x8001c5 <__TEXT_REGION_LENGTH__+0x7001c5>
	lds	r24, NVM_DATA2      ; Load NVM Data Register 2 into R24.
   20340:	80 91 c6 01 	lds	r24, 0x01C6	; 0x8001c6 <__TEXT_REGION_LENGTH__+0x7001c6>
	clr	r25                 ; Clear R25 in order to return a clean 32-bit value.
   20344:	99 27       	eor	r25, r25
	ret
   20346:	08 95       	ret

00020348 <SP_CommonLPM>:
; ---

.section .text		

SP_CommonLPM:
	movw	ZL, r24             ; Load index into Z.
   20348:	fc 01       	movw	r30, r24
	sts	NVM_CMD, r20        ; Load prepared command into NVM Command register.
   2034a:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm	r24,Z
   2034e:	84 91       	lpm	r24, Z
	ret
   20350:	08 95       	ret

00020352 <_ZN7CSerial13RecievedblockEPhi>:
    else
    {
	    TWIC_MASTER_CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    }
    return byte;
}
   20352:	ef 92       	push	r14
   20354:	ff 92       	push	r15
   20356:	0f 93       	push	r16
   20358:	1f 93       	push	r17
   2035a:	cf 93       	push	r28
   2035c:	df 93       	push	r29
   2035e:	14 16       	cp	r1, r20
   20360:	15 06       	cpc	r1, r21
   20362:	94 f4       	brge	.+36     	; 0x20388 <_ZN7CSerial13RecievedblockEPhi+0x36>
   20364:	8b 01       	movw	r16, r22
   20366:	7c 01       	movw	r14, r24
   20368:	eb 01       	movw	r28, r22
   2036a:	04 0f       	add	r16, r20
   2036c:	15 1f       	adc	r17, r21
   2036e:	be 01       	movw	r22, r28
   20370:	c7 01       	movw	r24, r14
   20372:	0f 94 e9 01 	call	0x203d2	; 0x203d2 <_ZN7CSerial12RecievedcharERh>
   20376:	00 97       	sbiw	r24, 0x00	; 0
   20378:	49 f0       	breq	.+18     	; 0x2038c <_ZN7CSerial13RecievedblockEPhi+0x3a>
   2037a:	21 96       	adiw	r28, 0x01	; 1
   2037c:	c0 17       	cp	r28, r16
   2037e:	d1 07       	cpc	r29, r17
   20380:	b1 f7       	brne	.-20     	; 0x2036e <_ZN7CSerial13RecievedblockEPhi+0x1c>
   20382:	81 e0       	ldi	r24, 0x01	; 1
   20384:	90 e0       	ldi	r25, 0x00	; 0
   20386:	02 c0       	rjmp	.+4      	; 0x2038c <_ZN7CSerial13RecievedblockEPhi+0x3a>
   20388:	81 e0       	ldi	r24, 0x01	; 1
   2038a:	90 e0       	ldi	r25, 0x00	; 0
   2038c:	df 91       	pop	r29
   2038e:	cf 91       	pop	r28
   20390:	1f 91       	pop	r17
   20392:	0f 91       	pop	r16
   20394:	ff 90       	pop	r15
   20396:	ef 90       	pop	r14
   20398:	08 95       	ret

0002039a <_ZN7CSerial13TransmitBlockEPhi>:
   2039a:	ef 92       	push	r14
   2039c:	ff 92       	push	r15
   2039e:	0f 93       	push	r16
   203a0:	1f 93       	push	r17
   203a2:	cf 93       	push	r28
   203a4:	df 93       	push	r29
   203a6:	14 16       	cp	r1, r20
   203a8:	15 06       	cpc	r1, r21
   203aa:	64 f4       	brge	.+24     	; 0x203c4 <_ZN7CSerial13TransmitBlockEPhi+0x2a>
   203ac:	8b 01       	movw	r16, r22
   203ae:	7c 01       	movw	r14, r24
   203b0:	eb 01       	movw	r28, r22
   203b2:	04 0f       	add	r16, r20
   203b4:	15 1f       	adc	r17, r21
   203b6:	69 91       	ld	r22, Y+
   203b8:	c7 01       	movw	r24, r14
   203ba:	0f 94 23 02 	call	0x20446	; 0x20446 <_ZN7CSerial8SendcharEh>
   203be:	c0 17       	cp	r28, r16
   203c0:	d1 07       	cpc	r29, r17
   203c2:	c9 f7       	brne	.-14     	; 0x203b6 <_ZN7CSerial13TransmitBlockEPhi+0x1c>
   203c4:	df 91       	pop	r29
   203c6:	cf 91       	pop	r28
   203c8:	1f 91       	pop	r17
   203ca:	0f 91       	pop	r16
   203cc:	ff 90       	pop	r15
   203ce:	ef 90       	pop	r14
   203d0:	08 95       	ret

000203d2 <_ZN7CSerial12RecievedcharERh>:
   203d2:	cf 93       	push	r28
   203d4:	df 93       	push	r29
   203d6:	00 d0       	rcall	.+0      	; 0x203d8 <_ZN7CSerial12RecievedcharERh+0x6>
   203d8:	00 d0       	rcall	.+0      	; 0x203da <_ZN7CSerial12RecievedcharERh+0x8>
   203da:	cd b7       	in	r28, 0x3d	; 61
   203dc:	de b7       	in	r29, 0x3e	; 62
   203de:	8b 83       	std	Y+3, r24	; 0x03
   203e0:	9c 83       	std	Y+4, r25	; 0x04
   203e2:	6d 83       	std	Y+5, r22	; 0x05
   203e4:	7e 83       	std	Y+6, r23	; 0x06
   203e6:	19 82       	std	Y+1, r1	; 0x01
   203e8:	1a 82       	std	Y+2, r1	; 0x02
   203ea:	8b 81       	ldd	r24, Y+3	; 0x03
   203ec:	9c 81       	ldd	r25, Y+4	; 0x04
   203ee:	fc 01       	movw	r30, r24
   203f0:	80 81       	ld	r24, Z
   203f2:	91 81       	ldd	r25, Z+1	; 0x01
   203f4:	fc 01       	movw	r30, r24
   203f6:	81 81       	ldd	r24, Z+1	; 0x01
   203f8:	80 95       	com	r24
   203fa:	88 1f       	adc	r24, r24
   203fc:	88 27       	eor	r24, r24
   203fe:	88 1f       	adc	r24, r24
   20400:	88 23       	and	r24, r24
   20402:	71 f0       	breq	.+28     	; 0x20420 <_ZN7CSerial12RecievedcharERh+0x4e>
   20404:	89 81       	ldd	r24, Y+1	; 0x01
   20406:	9a 81       	ldd	r25, Y+2	; 0x02
   20408:	84 33       	cpi	r24, 0x34	; 52
   2040a:	98 40       	sbci	r25, 0x08	; 8
   2040c:	19 f4       	brne	.+6      	; 0x20414 <_ZN7CSerial12RecievedcharERh+0x42>
   2040e:	80 e0       	ldi	r24, 0x00	; 0
   20410:	90 e0       	ldi	r25, 0x00	; 0
   20412:	13 c0       	rjmp	.+38     	; 0x2043a <_ZN7CSerial12RecievedcharERh+0x68>
   20414:	89 81       	ldd	r24, Y+1	; 0x01
   20416:	9a 81       	ldd	r25, Y+2	; 0x02
   20418:	01 96       	adiw	r24, 0x01	; 1
   2041a:	89 83       	std	Y+1, r24	; 0x01
   2041c:	9a 83       	std	Y+2, r25	; 0x02
   2041e:	e5 cf       	rjmp	.-54     	; 0x203ea <_ZN7CSerial12RecievedcharERh+0x18>
   20420:	8b 81       	ldd	r24, Y+3	; 0x03
   20422:	9c 81       	ldd	r25, Y+4	; 0x04
   20424:	fc 01       	movw	r30, r24
   20426:	80 81       	ld	r24, Z
   20428:	91 81       	ldd	r25, Z+1	; 0x01
   2042a:	fc 01       	movw	r30, r24
   2042c:	20 81       	ld	r18, Z
   2042e:	8d 81       	ldd	r24, Y+5	; 0x05
   20430:	9e 81       	ldd	r25, Y+6	; 0x06
   20432:	fc 01       	movw	r30, r24
   20434:	20 83       	st	Z, r18
   20436:	81 e0       	ldi	r24, 0x01	; 1
   20438:	90 e0       	ldi	r25, 0x00	; 0
   2043a:	26 96       	adiw	r28, 0x06	; 6
   2043c:	cd bf       	out	0x3d, r28	; 61
   2043e:	de bf       	out	0x3e, r29	; 62
   20440:	df 91       	pop	r29
   20442:	cf 91       	pop	r28
   20444:	08 95       	ret

00020446 <_ZN7CSerial8SendcharEh>:
   20446:	dc 01       	movw	r26, r24
   20448:	ed 91       	ld	r30, X+
   2044a:	fc 91       	ld	r31, X
   2044c:	81 81       	ldd	r24, Z+1	; 0x01
   2044e:	85 ff       	sbrs	r24, 5
   20450:	fd cf       	rjmp	.-6      	; 0x2044c <_ZN7CSerial8SendcharEh+0x6>
   20452:	60 83       	st	Z, r22
   20454:	08 95       	ret

00020456 <_ZN4CPin10shim10n100Ev>:
   20456:	fc 01       	movw	r30, r24
   20458:	a0 81       	ld	r26, Z
   2045a:	b1 81       	ldd	r27, Z+1	; 0x01
   2045c:	82 81       	ldd	r24, Z+2	; 0x02
   2045e:	15 96       	adiw	r26, 0x05	; 5
   20460:	8c 93       	st	X, r24
   20462:	8a e6       	ldi	r24, 0x6A	; 106
   20464:	8a 95       	dec	r24
   20466:	f1 f7       	brne	.-4      	; 0x20464 <_ZN4CPin10shim10n100Ev+0xe>
   20468:	00 c0       	rjmp	.+0      	; 0x2046a <_ZN4CPin10shim10n100Ev+0x14>
   2046a:	a0 81       	ld	r26, Z
   2046c:	b1 81       	ldd	r27, Z+1	; 0x01
   2046e:	82 81       	ldd	r24, Z+2	; 0x02
   20470:	16 96       	adiw	r26, 0x06	; 6
   20472:	8c 93       	st	X, r24
   20474:	8f e1       	ldi	r24, 0x1F	; 31
   20476:	93 e0       	ldi	r25, 0x03	; 3
   20478:	01 97       	sbiw	r24, 0x01	; 1
   2047a:	f1 f7       	brne	.-4      	; 0x20478 <_ZN4CPin10shim10n100Ev+0x22>
   2047c:	00 c0       	rjmp	.+0      	; 0x2047e <_ZN4CPin10shim10n100Ev+0x28>
   2047e:	00 00       	nop
   20480:	08 95       	ret

00020482 <_ZN4CPin5OnPinEv>:
   20482:	dc 01       	movw	r26, r24
   20484:	ed 91       	ld	r30, X+
   20486:	fc 91       	ld	r31, X
   20488:	11 97       	sbiw	r26, 0x01	; 1
   2048a:	20 85       	ldd	r18, Z+8	; 0x08
   2048c:	30 e0       	ldi	r19, 0x00	; 0
   2048e:	12 96       	adiw	r26, 0x02	; 2
   20490:	8d 91       	ld	r24, X+
   20492:	9c 91       	ld	r25, X
   20494:	13 97       	sbiw	r26, 0x03	; 3
   20496:	28 23       	and	r18, r24
   20498:	39 23       	and	r19, r25
   2049a:	81 e0       	ldi	r24, 0x01	; 1
   2049c:	23 2b       	or	r18, r19
   2049e:	09 f4       	brne	.+2      	; 0x204a2 <_ZN4CPin5OnPinEv+0x20>
   204a0:	80 e0       	ldi	r24, 0x00	; 0
   204a2:	08 95       	ret

000204a4 <_Z8exitbootv>:
bool end_of_flashing;
void exitboot();

void exitboot(){
	void (*gotozero)() = 0x0000;
	cli();
   204a4:	f8 94       	cli
	SP_WaitForSPM();
   204a6:	0f 94 8c 01 	call	0x20318	; 0x20318 <SP_WaitForSPM>
	SP_LockSPM();
   204aa:	0f 94 85 01 	call	0x2030a	; 0x2030a <SP_LockSPM>
	USARTD1_CTRLA = USART_RXCINTLVL_OFF_gc;
   204ae:	10 92 b3 09 	sts	0x09B3, r1	; 0x8009b3 <__TEXT_REGION_LENGTH__+0x7009b3>
	EIND = 0x00;
   204b2:	1c be       	out	0x3c, r1	; 60
	gotozero();
   204b4:	e0 e0       	ldi	r30, 0x00	; 0
   204b6:	f0 e0       	ldi	r31, 0x00	; 0
   204b8:	19 95       	eicall
   204ba:	08 95       	ret

000204bc <main>:
}

 int main(void) 
{   
   204bc:	cf 93       	push	r28
   204be:	df 93       	push	r29
   204c0:	cd b7       	in	r28, 0x3d	; 61
   204c2:	de b7       	in	r29, 0x3e	; 62
   204c4:	28 97       	sbiw	r28, 0x08	; 8
   204c6:	cd bf       	out	0x3d, r28	; 61
   204c8:	de bf       	out	0x3e, r29	; 62
class CCpu
{
     public:
     CCpu(){
	 //----------------InitCPU
	 OSC_CTRL = (1<<OSC_RC32MEN_bp);//разрешаем работу внутреннего тактового генератора 32MHz
   204ca:	82 e0       	ldi	r24, 0x02	; 2
   204cc:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
	 while(!(OSC_STATUS & (1<<OSC_RC32MRDY_bp))); // Ожидание готовности внутреннего тактового генератора 32MHz;
   204d0:	e1 e5       	ldi	r30, 0x51	; 81
   204d2:	f0 e0       	ldi	r31, 0x00	; 0
   204d4:	80 81       	ld	r24, Z
   204d6:	81 ff       	sbrs	r24, 1
   204d8:	fd cf       	rjmp	.-6      	; 0x204d4 <main+0x18>
	 CCP = 0xD8; //Разрешение записи в защищённый регистр
   204da:	28 ed       	ldi	r18, 0xD8	; 216
   204dc:	24 bf       	out	0x34, r18	; 52
	 CLK_CTRL = 1;
   204de:	91 e0       	ldi	r25, 0x01	; 1
   204e0:	90 93 40 00 	sts	0x0040, r25	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
class CInterrupt
{
    public:
	CInterrupt(){}
	CInterrupt(int usesection){
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm ;// активация контроллера прерываний 10 bytes PM
   204e4:	e0 ea       	ldi	r30, 0xA0	; 160
   204e6:	f0 e0       	ldi	r31, 0x00	; 0
   204e8:	82 81       	ldd	r24, Z+2	; 0x02
   204ea:	87 60       	ori	r24, 0x07	; 7
   204ec:	82 83       	std	Z+2, r24	; 0x02
	if(usesection == Boot)
	{
	      CCP = CCP_IOREG_gc; //Разрешение записи в защищённый регистр
   204ee:	24 bf       	out	0x34, r18	; 52
	      PMIC.CTRL |= PMIC_IVSEL_bm;  // активация таблицы прерываний загрузочного сектора
   204f0:	82 81       	ldd	r24, Z+2	; 0x02
   204f2:	80 64       	ori	r24, 0x40	; 64
   204f4:	82 83       	std	Z+2, r24	; 0x02
     int pin;
  public: 
      

       CPin(PORT_t *port,int pinnum,int direct){
	   portn = port;
   204f6:	e0 e2       	ldi	r30, 0x20	; 32
   204f8:	f7 e0       	ldi	r31, 0x07	; 7
   204fa:	e9 83       	std	Y+1, r30	; 0x01
   204fc:	fa 83       	std	Y+2, r31	; 0x02
	   pin = pinnum;
   204fe:	21 e0       	ldi	r18, 0x01	; 1
   20500:	30 e0       	ldi	r19, 0x00	; 0
   20502:	2b 83       	std	Y+3, r18	; 0x03
   20504:	3c 83       	std	Y+4, r19	; 0x04
	   if(direct)
	   port->DIRSET = pinnum;
   20506:	91 83       	std	Z+1, r25	; 0x01
   20508:	84 e0       	ldi	r24, 0x04	; 4
   2050a:	81 83       	std	Z+1, r24	; 0x01
     int pin;
  public: 
      

       CPin(PORT_t *port,int pinnum,int direct){
	   portn = port;
   2050c:	ed 83       	std	Y+5, r30	; 0x05
   2050e:	fe 83       	std	Y+6, r31	; 0x06
	   pin = pinnum;
   20510:	80 e2       	ldi	r24, 0x20	; 32
   20512:	90 e0       	ldi	r25, 0x00	; 0
   20514:	8f 83       	std	Y+7, r24	; 0x07
   20516:	98 87       	std	Y+8, r25	; 0x08
	CSerial(int rate,int device)
	{
		if(device == microe793)
		{
			port = &USARTC0;//port C0 is used
			if(rate == bdrate19200 || rate == bdrate200000){USARTC0_BAUDCTRLB = 0;USARTC0_BAUDCTRLA = rate;}
   20518:	10 92 a7 08 	sts	0x08A7, r1	; 0x8008a7 <__TEXT_REGION_LENGTH__+0x7008a7>
   2051c:	89 e0       	ldi	r24, 0x09	; 9
   2051e:	80 93 a6 08 	sts	0x08A6, r24	; 0x8008a6 <__TEXT_REGION_LENGTH__+0x7008a6>
			if(rate == bdrate115200){USARTC0_BAUDCTRLB = 208; USARTC0_BAUDCTRLA = rate;}
			
			USARTC0_CTRLA = USART_RXCINTLVL_MED_gc; //подключение прерываний
   20522:	80 e2       	ldi	r24, 0x20	; 32
   20524:	80 93 a3 08 	sts	0x08A3, r24	; 0x8008a3 <__TEXT_REGION_LENGTH__+0x7008a3>
			USARTC0_CTRLC = USART_CHSIZE_8BIT_gc; //8 data bits, no parity and 1 stop bit
   20528:	83 e0       	ldi	r24, 0x03	; 3
   2052a:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <__TEXT_REGION_LENGTH__+0x7008a5>
			USARTC0_CTRLB = USART_TXEN_bm | USART_RXEN_bm; //Включение приема передатчика
   2052e:	88 e1       	ldi	r24, 0x18	; 24
   20530:	80 93 a4 08 	sts	0x08A4, r24	; 0x8008a4 <__TEXT_REGION_LENGTH__+0x7008a4>
			PORTC.DIRSET = PIN3_bm;  // настройка ноги 3 порта С контроллера Xmega на выход!для передачи данных в микросхему Uart
   20534:	88 e0       	ldi	r24, 0x08	; 8
   20536:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>

public:
    CTwi(){}
	CTwi(int speed){
	//----------------InitTWI
	TWIC.CTRL = 0;
   2053a:	10 92 80 04 	sts	0x0480, r1	; 0x800480 <__TEXT_REGION_LENGTH__+0x700480>
	TWIC_MASTER_BAUD=speed;// При 32 Мгц, на 100кГц = 155(0x9B)
   2053e:	9b e9       	ldi	r25, 0x9B	; 155
   20540:	90 93 85 04 	sts	0x0485, r25	; 0x800485 <__TEXT_REGION_LENGTH__+0x700485>
	TWIC_MASTER_CTRLA=TWI_MASTER_ENABLE_bm; //enable master
   20544:	80 93 81 04 	sts	0x0481, r24	; 0x800481 <__TEXT_REGION_LENGTH__+0x700481>
	TWIC_MASTER_CTRLB=0x00; //disable Inactive Bus Timeout, disable QCEN and SMEN
   20548:	10 92 82 04 	sts	0x0482, r1	; 0x800482 <__TEXT_REGION_LENGTH__+0x700482>
	TWIC_MASTER_CTRLC=0x00; //send ACK and NOACT initially
   2054c:	10 92 83 04 	sts	0x0483, r1	; 0x800483 <__TEXT_REGION_LENGTH__+0x700483>
	TWIC_MASTER_STATUS=TWI_MASTER_RIF_bm|TWI_MASTER_WIF_bm|TWI_MASTER_ARBLOST_bm|TWI_MASTER_BUSERR_bm|TWI_MASTER_BUSSTATE0_bm; //initially clear all flags and select bus state as IDLE
   20550:	8d ec       	ldi	r24, 0xCD	; 205
   20552:	80 93 84 04 	sts	0x0484, r24	; 0x800484 <__TEXT_REGION_LENGTH__+0x700484>
}

void CPin::PullDown(int numPin)
{
    if(numPin == 5)
    portn->PIN5CTRL = PORT_OPC_PULLDOWN_gc;
   20556:	ed 81       	ldd	r30, Y+5	; 0x05
   20558:	fe 81       	ldd	r31, Y+6	; 0x06
   2055a:	80 e1       	ldi	r24, 0x10	; 16
   2055c:	85 8b       	std	Z+21, r24	; 0x15
	void disable();
};

void CInterrupt::enable()
{
     sei();
   2055e:	78 94       	sei
             
   inter.enable();
   
    while (1) 
    { 	 
	   pin0portK.shim10n100();
   20560:	ce 01       	movw	r24, r28
   20562:	01 96       	adiw	r24, 0x01	; 1
   20564:	0f 94 2b 02 	call	0x20456	; 0x20456 <_ZN4CPin10shim10n100Ev>
	   //pin2portK.shim10n100();

	    if(pin5portK.OnPin()) // || Onboot
   20568:	ce 01       	movw	r24, r28
   2056a:	05 96       	adiw	r24, 0x05	; 5
   2056c:	0f 94 41 02 	call	0x20482	; 0x20482 <_ZN4CPin5OnPinEv>
	    {
		    Onboot = true;					
	    }
	    if(!pin5portK.OnPin() || end_of_flashing)
   20570:	ce 01       	movw	r24, r28
   20572:	05 96       	adiw	r24, 0x05	; 5
   20574:	0f 94 41 02 	call	0x20482	; 0x20482 <_ZN4CPin5OnPinEv>
   20578:	88 23       	and	r24, r24
   2057a:	21 f0       	breq	.+8      	; 0x20584 <main+0xc8>
   2057c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <_edata>
   20580:	88 23       	and	r24, r24
   20582:	71 f3       	breq	.-36     	; 0x20560 <main+0xa4>
}


void CPin::outclr()
{
    portn->OUTCLR = pin; 
   20584:	e9 81       	ldd	r30, Y+1	; 0x01
   20586:	fa 81       	ldd	r31, Y+2	; 0x02
   20588:	8b 81       	ldd	r24, Y+3	; 0x03
   2058a:	86 83       	std	Z+6, r24	; 0x06
	    {
		    pin0portK.outclr();
		    exitboot();
   2058c:	0f 94 52 02 	call	0x204a4	; 0x204a4 <_Z8exitbootv>
   20590:	e7 cf       	rjmp	.-50     	; 0x20560 <main+0xa4>

00020592 <__vector_25>:
	    }
    }
}

ISR(USARTC0_RXC_vect)
{
   20592:	1f 92       	push	r1
   20594:	0f 92       	push	r0
   20596:	0f b6       	in	r0, 0x3f	; 63
   20598:	0f 92       	push	r0
   2059a:	11 24       	eor	r1, r1
   2059c:	08 b6       	in	r0, 0x38	; 56
   2059e:	0f 92       	push	r0
   205a0:	18 be       	out	0x38, r1	; 56
   205a2:	09 b6       	in	r0, 0x39	; 57
   205a4:	0f 92       	push	r0
   205a6:	19 be       	out	0x39, r1	; 57
   205a8:	0a b6       	in	r0, 0x3a	; 58
   205aa:	0f 92       	push	r0
   205ac:	1a be       	out	0x3a, r1	; 58
   205ae:	0b b6       	in	r0, 0x3b	; 59
   205b0:	0f 92       	push	r0
   205b2:	1b be       	out	0x3b, r1	; 59
   205b4:	8f 92       	push	r8
   205b6:	9f 92       	push	r9
   205b8:	af 92       	push	r10
   205ba:	bf 92       	push	r11
   205bc:	cf 92       	push	r12
   205be:	df 92       	push	r13
   205c0:	ef 92       	push	r14
   205c2:	ff 92       	push	r15
   205c4:	0f 93       	push	r16
   205c6:	1f 93       	push	r17
   205c8:	2f 93       	push	r18
   205ca:	3f 93       	push	r19
   205cc:	4f 93       	push	r20
   205ce:	5f 93       	push	r21
   205d0:	6f 93       	push	r22
   205d2:	7f 93       	push	r23
   205d4:	8f 93       	push	r24
   205d6:	9f 93       	push	r25
   205d8:	af 93       	push	r26
   205da:	bf 93       	push	r27
   205dc:	ef 93       	push	r30
   205de:	ff 93       	push	r31
   205e0:	cf 93       	push	r28
   205e2:	df 93       	push	r29
   205e4:	cd b7       	in	r28, 0x3d	; 61
   205e6:	de b7       	in	r29, 0x3e	; 62
   205e8:	c2 5c       	subi	r28, 0xC2	; 194
   205ea:	d2 40       	sbci	r29, 0x02	; 2
   205ec:	cd bf       	out	0x3d, r28	; 61
   205ee:	de bf       	out	0x3e, r29	; 62
	USART_t * port;
	public:
	CSerial(){}
	CSerial(USART_t * port_t)
	{
		port = port_t;
   205f0:	80 ea       	ldi	r24, 0xA0	; 160
   205f2:	98 e0       	ldi	r25, 0x08	; 8
   205f4:	89 83       	std	Y+1, r24	; 0x01
   205f6:	9a 83       	std	Y+2, r25	; 0x02

	CSerial       uart(&USARTC0);
	CTwi          twi;
	
	unsigned char block[700] = { 0 };
   205f8:	be 01       	movw	r22, r28
   205fa:	6d 5f       	subi	r22, 0xFD	; 253
   205fc:	7f 4f       	sbci	r23, 0xFF	; 255
   205fe:	8c eb       	ldi	r24, 0xBC	; 188
   20600:	92 e0       	ldi	r25, 0x02	; 2
   20602:	fb 01       	movw	r30, r22
   20604:	9c 01       	movw	r18, r24
   20606:	11 92       	st	Z+, r1
   20608:	21 50       	subi	r18, 0x01	; 1
   2060a:	30 40       	sbci	r19, 0x00	; 0
   2060c:	e1 f7       	brne	.-8      	; 0x20606 <__vector_25+0x74>
	unsigned char answerFlash[] = { 0xff,0x02,0x04,0x0A };
   2060e:	8f ef       	ldi	r24, 0xFF	; 255
   20610:	c1 54       	subi	r28, 0x41	; 65
   20612:	dd 4f       	sbci	r29, 0xFD	; 253
   20614:	88 83       	st	Y, r24
   20616:	cf 5b       	subi	r28, 0xBF	; 191
   20618:	d2 40       	sbci	r29, 0x02	; 2
   2061a:	82 e0       	ldi	r24, 0x02	; 2
   2061c:	c0 54       	subi	r28, 0x40	; 64
   2061e:	dd 4f       	sbci	r29, 0xFD	; 253
   20620:	88 83       	st	Y, r24
   20622:	c0 5c       	subi	r28, 0xC0	; 192
   20624:	d2 40       	sbci	r29, 0x02	; 2
   20626:	84 e0       	ldi	r24, 0x04	; 4
   20628:	cf 53       	subi	r28, 0x3F	; 63
   2062a:	dd 4f       	sbci	r29, 0xFD	; 253
   2062c:	88 83       	st	Y, r24
   2062e:	c1 5c       	subi	r28, 0xC1	; 193
   20630:	d2 40       	sbci	r29, 0x02	; 2
   20632:	8a e0       	ldi	r24, 0x0A	; 10
   20634:	ce 53       	subi	r28, 0x3E	; 62
   20636:	dd 4f       	sbci	r29, 0xFD	; 253
   20638:	88 83       	st	Y, r24
   2063a:	c2 5c       	subi	r28, 0xC2	; 194
   2063c:	d2 40       	sbci	r29, 0x02	; 2

	uart.Recievedblock(block,sizeof(block));
   2063e:	4c eb       	ldi	r20, 0xBC	; 188
   20640:	52 e0       	ldi	r21, 0x02	; 2
   20642:	ce 01       	movw	r24, r28
   20644:	01 96       	adiw	r24, 0x01	; 1
   20646:	0f 94 a9 01 	call	0x20352	; 0x20352 <_ZN7CSerial13RecievedblockEPhi>
	
	if ( block[3] == WRITE_ || block[3] == 0x83)
   2064a:	8e 81       	ldd	r24, Y+6	; 0x06
   2064c:	83 30       	cpi	r24, 0x03	; 3
   2064e:	61 f0       	breq	.+24     	; 0x20668 <__vector_25+0xd6>
   20650:	83 38       	cpi	r24, 0x83	; 131
   20652:	c1 f5       	brne	.+112    	; 0x206c4 <__vector_25+0x132>
	{
		unsigned long addres_page;

		if(block[3] == 0x83)
			addres_page = 255 + (int)block[6];
   20654:	89 84       	ldd	r8, Y+9	; 0x09
   20656:	91 2c       	mov	r9, r1
   20658:	3f ef       	ldi	r19, 0xFF	; 255
   2065a:	83 0e       	add	r8, r19
   2065c:	91 1c       	adc	r9, r1
   2065e:	09 2c       	mov	r0, r9
   20660:	00 0c       	add	r0, r0
   20662:	aa 08       	sbc	r10, r10
   20664:	bb 08       	sbc	r11, r11
   20666:	53 c0       	rjmp	.+166    	; 0x2070e <__vector_25+0x17c>
		else
			addres_page = (int)block[6] - 1;
   20668:	89 84       	ldd	r8, Y+9	; 0x09
   2066a:	91 2c       	mov	r9, r1
   2066c:	81 e0       	ldi	r24, 0x01	; 1
   2066e:	88 1a       	sub	r8, r24
   20670:	91 08       	sbc	r9, r1
   20672:	09 2c       	mov	r0, r9
   20674:	00 0c       	add	r0, r0
   20676:	aa 08       	sbc	r10, r10
   20678:	bb 08       	sbc	r11, r11
   2067a:	49 c0       	rjmp	.+146    	; 0x2070e <__vector_25+0x17c>
			return;
		
		for(int x=0;x<APP_SECTION_PAGE_SIZE;x+=2)
		{
			uint16_t word;
			word = (uint8_t) block[x + 8];          //low
   2067c:	f6 01       	movw	r30, r12
   2067e:	00 81       	ld	r16, Z
			word |= (uint8_t) block[x + 9]<<8;      //hi
   20680:	81 81       	ldd	r24, Z+1	; 0x01
   20682:	10 e0       	ldi	r17, 0x00	; 0
   20684:	18 2b       	or	r17, r24
			SP_WaitForSPM();
   20686:	0f 94 8c 01 	call	0x20318	; 0x20318 <SP_WaitForSPM>
			SP_LoadFlashWord(x, word);
   2068a:	b8 01       	movw	r22, r16
   2068c:	c7 01       	movw	r24, r14
   2068e:	0f 94 49 01 	call	0x20292	; 0x20292 <SP_LoadFlashWord>
		addres_page = addres_page * 512;

		if(addres_page >= APP_END)
			return;
		
		for(int x=0;x<APP_SECTION_PAGE_SIZE;x+=2)
   20692:	f2 e0       	ldi	r31, 0x02	; 2
   20694:	ef 0e       	add	r14, r31
   20696:	f1 1c       	adc	r15, r1
   20698:	22 e0       	ldi	r18, 0x02	; 2
   2069a:	c2 0e       	add	r12, r18
   2069c:	d1 1c       	adc	r13, r1
   2069e:	e1 14       	cp	r14, r1
   206a0:	32 e0       	ldi	r19, 0x02	; 2
   206a2:	f3 06       	cpc	r15, r19
   206a4:	59 f7       	brne	.-42     	; 0x2067c <__vector_25+0xea>
			word = (uint8_t) block[x + 8];          //low
			word |= (uint8_t) block[x + 9]<<8;      //hi
			SP_WaitForSPM();
			SP_LoadFlashWord(x, word);
		}
		SP_WaitForSPM();
   206a6:	0f 94 8c 01 	call	0x20318	; 0x20318 <SP_WaitForSPM>
		SP_EraseWriteApplicationPage(addres_page);
   206aa:	c5 01       	movw	r24, r10
   206ac:	b4 01       	movw	r22, r8
   206ae:	0f 94 65 01 	call	0x202ca	; 0x202ca <SP_EraseWriteApplicationPage>

		uart.TransmitBlock(answerFlash,sizeof(answerFlash));
   206b2:	44 e0       	ldi	r20, 0x04	; 4
   206b4:	50 e0       	ldi	r21, 0x00	; 0
   206b6:	be 01       	movw	r22, r28
   206b8:	61 54       	subi	r22, 0x41	; 65
   206ba:	7d 4f       	sbci	r23, 0xFD	; 253
   206bc:	ce 01       	movw	r24, r28
   206be:	01 96       	adiw	r24, 0x01	; 1
   206c0:	0f 94 cd 01 	call	0x2039a	; 0x2039a <_ZN7CSerial13TransmitBlockEPhi>
	}


	if ( block[3] == TEST_ && block[4] == TEST_ ){ uart.TransmitBlock(block,8); }
   206c4:	8e 81       	ldd	r24, Y+6	; 0x06
   206c6:	85 35       	cpi	r24, 0x55	; 85
   206c8:	61 f4       	brne	.+24     	; 0x206e2 <__vector_25+0x150>
   206ca:	8f 81       	ldd	r24, Y+7	; 0x07
   206cc:	85 35       	cpi	r24, 0x55	; 85
   206ce:	a9 f5       	brne	.+106    	; 0x2073a <__vector_25+0x1a8>
   206d0:	48 e0       	ldi	r20, 0x08	; 8
   206d2:	50 e0       	ldi	r21, 0x00	; 0
   206d4:	be 01       	movw	r22, r28
   206d6:	6d 5f       	subi	r22, 0xFD	; 253
   206d8:	7f 4f       	sbci	r23, 0xFF	; 255
   206da:	ce 01       	movw	r24, r28
   206dc:	01 96       	adiw	r24, 0x01	; 1
   206de:	0f 94 cd 01 	call	0x2039a	; 0x2039a <_ZN7CSerial13TransmitBlockEPhi>

	if ( block[3] == SET_TIME && block[4] == SET_TIME) { uart.TransmitBlock(block,1); }
   206e2:	8e 81       	ldd	r24, Y+6	; 0x06
   206e4:	87 30       	cpi	r24, 0x07	; 7
   206e6:	61 f4       	brne	.+24     	; 0x20700 <__vector_25+0x16e>
   206e8:	8f 81       	ldd	r24, Y+7	; 0x07
   206ea:	87 30       	cpi	r24, 0x07	; 7
   206ec:	31 f5       	brne	.+76     	; 0x2073a <__vector_25+0x1a8>
   206ee:	41 e0       	ldi	r20, 0x01	; 1
   206f0:	50 e0       	ldi	r21, 0x00	; 0
   206f2:	be 01       	movw	r22, r28
   206f4:	6d 5f       	subi	r22, 0xFD	; 253
   206f6:	7f 4f       	sbci	r23, 0xFF	; 255
   206f8:	ce 01       	movw	r24, r28
   206fa:	01 96       	adiw	r24, 0x01	; 1
   206fc:	0f 94 cd 01 	call	0x2039a	; 0x2039a <_ZN7CSerial13TransmitBlockEPhi>

	if ( block[3] == WRITE_CHECK_ONES){ end_of_flashing = true;}
   20700:	8e 81       	ldd	r24, Y+6	; 0x06
   20702:	8c 33       	cpi	r24, 0x3C	; 60
   20704:	d1 f4       	brne	.+52     	; 0x2073a <__vector_25+0x1a8>
   20706:	81 e0       	ldi	r24, 0x01	; 1
   20708:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <_edata>
   2070c:	16 c0       	rjmp	.+44     	; 0x2073a <__vector_25+0x1a8>
		if(block[3] == 0x83)
			addres_page = 255 + (int)block[6];
		else
			addres_page = (int)block[6] - 1;

		addres_page = addres_page * 512;
   2070e:	07 2e       	mov	r0, r23
   20710:	79 e0       	ldi	r23, 0x09	; 9
   20712:	88 0c       	add	r8, r8
   20714:	99 1c       	adc	r9, r9
   20716:	aa 1c       	adc	r10, r10
   20718:	bb 1c       	adc	r11, r11
   2071a:	7a 95       	dec	r23
   2071c:	d1 f7       	brne	.-12     	; 0x20712 <__vector_25+0x180>
   2071e:	70 2d       	mov	r23, r0

		if(addres_page >= APP_END)
   20720:	81 14       	cp	r8, r1
   20722:	91 04       	cpc	r9, r1
   20724:	82 e0       	ldi	r24, 0x02	; 2
   20726:	a8 06       	cpc	r10, r24
   20728:	b1 04       	cpc	r11, r1
   2072a:	38 f4       	brcc	.+14     	; 0x2073a <__vector_25+0x1a8>
   2072c:	6e 01       	movw	r12, r28
   2072e:	eb e0       	ldi	r30, 0x0B	; 11
   20730:	ce 0e       	add	r12, r30
   20732:	d1 1c       	adc	r13, r1
   20734:	e1 2c       	mov	r14, r1
   20736:	f1 2c       	mov	r15, r1
   20738:	a1 cf       	rjmp	.-190    	; 0x2067c <__vector_25+0xea>
	if ( block[3] == SET_TIME && block[4] == SET_TIME) { uart.TransmitBlock(block,1); }

	if ( block[3] == WRITE_CHECK_ONES){ end_of_flashing = true;}
	
	return;	
}
   2073a:	ce 53       	subi	r28, 0x3E	; 62
   2073c:	dd 4f       	sbci	r29, 0xFD	; 253
   2073e:	cd bf       	out	0x3d, r28	; 61
   20740:	de bf       	out	0x3e, r29	; 62
   20742:	df 91       	pop	r29
   20744:	cf 91       	pop	r28
   20746:	ff 91       	pop	r31
   20748:	ef 91       	pop	r30
   2074a:	bf 91       	pop	r27
   2074c:	af 91       	pop	r26
   2074e:	9f 91       	pop	r25
   20750:	8f 91       	pop	r24
   20752:	7f 91       	pop	r23
   20754:	6f 91       	pop	r22
   20756:	5f 91       	pop	r21
   20758:	4f 91       	pop	r20
   2075a:	3f 91       	pop	r19
   2075c:	2f 91       	pop	r18
   2075e:	1f 91       	pop	r17
   20760:	0f 91       	pop	r16
   20762:	ff 90       	pop	r15
   20764:	ef 90       	pop	r14
   20766:	df 90       	pop	r13
   20768:	cf 90       	pop	r12
   2076a:	bf 90       	pop	r11
   2076c:	af 90       	pop	r10
   2076e:	9f 90       	pop	r9
   20770:	8f 90       	pop	r8
   20772:	0f 90       	pop	r0
   20774:	0b be       	out	0x3b, r0	; 59
   20776:	0f 90       	pop	r0
   20778:	0a be       	out	0x3a, r0	; 58
   2077a:	0f 90       	pop	r0
   2077c:	09 be       	out	0x39, r0	; 57
   2077e:	0f 90       	pop	r0
   20780:	08 be       	out	0x38, r0	; 56
   20782:	0f 90       	pop	r0
   20784:	0f be       	out	0x3f, r0	; 63
   20786:	0f 90       	pop	r0
   20788:	1f 90       	pop	r1
   2078a:	18 95       	reti

0002078c <_exit>:
   2078c:	f8 94       	cli

0002078e <__stop_program>:
   2078e:	ff cf       	rjmp	.-2      	; 0x2078e <__stop_program>

Disassembly of section .BOOT:

00020790 <SP_LoadFlashPage>:
		
.section .BOOT, "ax"
.global SP_LoadFlashPage

SP_LoadFlashPage:
	clr	ZL              ; Clear low byte of Z, to indicate start of page.
   20790:	ee 27       	eor	r30, r30
	clr	ZH              ; Clear high byte of Z, to indicate start of page.
   20792:	ff 27       	eor	r31, r31

	out	RAMPX, r1       ; Clear RAMPX pointer.
   20794:	19 be       	out	0x39, r1	; 57
	movw	XL, r24         ; Load X with data buffer address.
   20796:	dc 01       	movw	r26, r24

	ldi 	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command code in R20.
   20798:	43 e2       	ldi	r20, 0x23	; 35
	sts	NVM_CMD, r20                       ; Load it into NVM command register.
   2079a:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>

#if FLASH_PAGE_SIZE > 512
	ldi	r22, ((FLASH_PAGE_SIZE/2) >> 8)
#endif

	ldi	r21, ((FLASH_PAGE_SIZE/2)&0xFF)    ; Load R21 with page word count.
   2079e:	50 e0       	ldi	r21, 0x00	; 0
	ldi	r18, CCP_SPM_gc                    ; Prepare Protect SPM signature in R16.
   207a0:	2d e9       	ldi	r18, 0x9D	; 157

000207a2 <SP_LoadFlashPage_1>:

SP_LoadFlashPage_1:
	ld	r0, X+         ; Load low byte from buffer into R0.
   207a2:	0d 90       	ld	r0, X+
	ld	r1, X+         ; Load high byte from buffer into R1.
   207a4:	1d 90       	ld	r1, X+
	sts	CCP, r18       ; Enable SPM operation (this disables interrupts for 4 cycles).
   207a6:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	spm                    ; Self-program.
   207aa:	e8 95       	spm
	adiw	ZL, 2          ; Move Z to next Flash word.
   207ac:	32 96       	adiw	r30, 0x02	; 2

#if FLASH_PAGE_SIZE > 512
	subi	r21, 1         ; Decrement word count.
	sbci	r22, 0
#else
	dec	r21            ; Decrement word count.
   207ae:	5a 95       	dec	r21
#endif

	brne	SP_LoadFlashPage_1   ; Repeat until word cont is zero.
   207b0:	c1 f7       	brne	.-16     	; 0x207a2 <SP_LoadFlashPage_1>

	clr	r1                   ; Clear R1 for GCC _zero_reg_ to function properly.
   207b2:	11 24       	eor	r1, r1
	ret
   207b4:	08 95       	ret

000207b6 <SP_CommonSPM>:
; ---

.section .BOOT, "ax"

SP_CommonSPM:
	movw	ZL, r24          ; Load R25:R24 into Z.
   207b6:	fc 01       	movw	r30, r24
	sts	NVM_CMD, r20     ; Load prepared command into NVM Command register.
   207b8:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	ldi	r18, CCP_SPM_gc  ; Prepare Protect SPM signature in R18
   207bc:	2d e9       	ldi	r18, 0x9D	; 157
	sts	CCP, r18         ; Enable SPM operation (this disables interrupts for 4 cycles).
   207be:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	spm                      ; Self-program.
   207c2:	e8 95       	spm
	clr	r1               ; Clear R1 for GCC _zero_reg_ to function properly.
   207c4:	11 24       	eor	r1, r1
	out	RAMPZ, r19       ; Restore RAMPZ register.
   207c6:	3b bf       	out	0x3b, r19	; 59
	ret
   207c8:	08 95       	ret
