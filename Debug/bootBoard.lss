
bootBoard.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000876  00020000  00020000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .BOOT         0000003a  00020876  00020876  000008ea  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         00000000  00802000  00802000  00000924  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000001  00802000  00802000  00000924  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  00000924  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000954  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000000e0  00000000  00000000  00000998  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00004aba  00000000  00000000  00000a78  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000367b  00000000  00000000  00005532  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000de9  00000000  00000000  00008bad  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000270  00000000  00000000  00009998  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00002de2  00000000  00000000  00009c08  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000b73  00000000  00000000  0000c9ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000000f8  00000000  00000000  0000d560  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00020000 <__vectors>:
   20000:	0d 94 fa 00 	jmp	0x201f4	; 0x201f4 <__ctors_end>
   20004:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20008:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2000c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20010:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20014:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20018:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2001c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20020:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20024:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20028:	0d 94 0d 03 	jmp	0x2061a	; 0x2061a <__vector_10>
   2002c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20030:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20034:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20038:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2003c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20040:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20044:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20048:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2004c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20050:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20054:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20058:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2005c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20060:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20064:	0d 94 3c 03 	jmp	0x20678	; 0x20678 <__vector_25>
   20068:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2006c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20070:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20074:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20078:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2007c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20080:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20084:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20088:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2008c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20090:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20094:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20098:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2009c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200a0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200a4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200a8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200ac:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200b0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200b4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200b8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200bc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200c0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200c4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200c8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200cc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200d0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200d4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200d8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200dc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200e0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200e4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200e8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200ec:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200f0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200f4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200f8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   200fc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20100:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20104:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20108:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2010c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20110:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20114:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20118:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2011c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20120:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20124:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20128:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2012c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20130:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20134:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20138:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2013c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20140:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20144:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20148:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2014c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20150:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20154:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20158:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2015c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20160:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20164:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20168:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2016c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20170:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20174:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20178:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2017c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20180:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20184:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20188:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2018c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20190:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20194:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   20198:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   2019c:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201a0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201a4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201a8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201ac:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201b0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201b4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201b8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201bc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201c0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201c4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201c8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201cc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201d0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201d4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201d8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201dc:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201e0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201e4:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201e8:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201ec:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>
   201f0:	0d 94 12 01 	jmp	0x20224	; 0x20224 <__bad_interrupt>

000201f4 <__ctors_end>:
   201f4:	11 24       	eor	r1, r1
   201f6:	1f be       	out	0x3f, r1	; 63
   201f8:	cf ef       	ldi	r28, 0xFF	; 255
   201fa:	cd bf       	out	0x3d, r28	; 61
   201fc:	df e3       	ldi	r29, 0x3F	; 63
   201fe:	de bf       	out	0x3e, r29	; 62
   20200:	01 e0       	ldi	r16, 0x01	; 1
   20202:	0c bf       	out	0x3c, r16	; 60
   20204:	18 be       	out	0x38, r1	; 56
   20206:	19 be       	out	0x39, r1	; 57
   20208:	1a be       	out	0x3a, r1	; 58
   2020a:	1b be       	out	0x3b, r1	; 59

0002020c <__do_clear_bss>:
   2020c:	20 e2       	ldi	r18, 0x20	; 32
   2020e:	a0 e0       	ldi	r26, 0x00	; 0
   20210:	b0 e2       	ldi	r27, 0x20	; 32
   20212:	01 c0       	rjmp	.+2      	; 0x20216 <.do_clear_bss_start>

00020214 <.do_clear_bss_loop>:
   20214:	1d 92       	st	X+, r1

00020216 <.do_clear_bss_start>:
   20216:	a1 30       	cpi	r26, 0x01	; 1
   20218:	b2 07       	cpc	r27, r18
   2021a:	e1 f7       	brne	.-8      	; 0x20214 <.do_clear_bss_loop>
   2021c:	0f 94 96 02 	call	0x2052c	; 0x2052c <main>
   20220:	0d 94 39 04 	jmp	0x20872	; 0x20872 <_exit>

00020224 <__bad_interrupt>:
   20224:	0d 94 00 00 	jmp	0x20000	; 0x20000 <__vectors>

00020228 <SP_ReadByte>:

.section .text
.global SP_ReadByte

SP_ReadByte:
	in	r19, RAMPZ      ; Save RAMPZ.
   20228:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
   2022a:	8b bf       	out	0x3b, r24	; 59
	movw	ZL, r22         ; Move the low bytes to the Z pointer
   2022c:	fb 01       	movw	r30, r22
	elpm	r24, Z          ; Extended load byte from address pointed to by Z.
   2022e:	86 91       	elpm	r24, Z
	out	RAMPZ, r19      ; Restore RAMPZ register.
   20230:	3b bf       	out	0x3b, r19	; 59
	ret
   20232:	08 95       	ret

00020234 <SP_ReadWord>:

.section .text
.global SP_ReadWord

SP_ReadWord:
	in	r19, RAMPZ      ; Save RAMPZ.
   20234:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
   20236:	8b bf       	out	0x3b, r24	; 59
	movw	ZL, r22         ; Move the low bytes to the Z pointer
   20238:	fb 01       	movw	r30, r22
	elpm	r24, Z+         ; Extended load byte from address pointed to by Z.
   2023a:	87 91       	elpm	r24, Z+
	elpm	r25, Z          ; Extended load byte from address pointed to by Z.
   2023c:	96 91       	elpm	r25, Z
	out	RAMPZ, r19      ; Restore RAMPZ register.
   2023e:	3b bf       	out	0x3b, r19	; 59
	ret
   20240:	08 95       	ret

00020242 <SP_ReadCalibrationByte>:

.section .text
.global SP_ReadCalibrationByte	

SP_ReadCalibrationByte:
	ldi	r20, NVM_CMD_READ_CALIB_ROW_gc    ; Prepare NVM command in R20.
   20242:	42 e0       	ldi	r20, 0x02	; 2
	rjmp	SP_CommonLPM                      ; Jump to common LPM code.
   20244:	81 c0       	rjmp	.+258    	; 0x20348 <SP_CommonLPM>

00020246 <SP_ReadUserSignatureByte>:

.section .text	
.global SP_ReadUserSignatureByte

SP_ReadUserSignatureByte:
	ldi	r20, NVM_CMD_READ_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
   20246:	41 e0       	ldi	r20, 0x01	; 1
	rjmp	SP_CommonLPM                       ; Jump to common LPM code.
   20248:	7f c0       	rjmp	.+254    	; 0x20348 <SP_CommonLPM>

0002024a <SP_ReadFuseByte>:

.section .text	
.global SP_ReadFuseByte

SP_ReadFuseByte:
	sts	NVM_ADDR0, r24              ; Load fuse byte index into NVM Address Register 0.
   2024a:	80 93 c0 01 	sts	0x01C0, r24	; 0x8001c0 <__TEXT_REGION_LENGTH__+0x7001c0>
	clr	r24                         ; Prepare a zero.
   2024e:	88 27       	eor	r24, r24
	sts	NVM_ADDR1, r24              ; Load zero into NVM Address Register 1.
   20250:	80 93 c1 01 	sts	0x01C1, r24	; 0x8001c1 <__TEXT_REGION_LENGTH__+0x7001c1>
	sts	NVM_ADDR2, r24              ; Load zero into NVM Address Register 2.
   20254:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <__TEXT_REGION_LENGTH__+0x7001c2>
	ldi	r20, NVM_CMD_READ_FUSES_gc  ; Prepare NVM command in R20.
   20258:	47 e0       	ldi	r20, 0x07	; 7
	rcall	SP_CommonCMD                ; Jump to common NVM Action code.
   2025a:	66 d0       	rcall	.+204    	; 0x20328 <SP_CommonCMD>
	movw	r24, r22                    ; Move low byte to 1 byte return address.
   2025c:	cb 01       	movw	r24, r22
	ret
   2025e:	08 95       	ret

00020260 <SP_WriteLockBits>:

.section .text	
.global SP_WriteLockBits

SP_WriteLockBits:
	sts	NVM_DATA0, r24                  ; Load lock bits into NVM Data Register 0.
   20260:	80 93 c4 01 	sts	0x01C4, r24	; 0x8001c4 <__TEXT_REGION_LENGTH__+0x7001c4>
	ldi	r20, NVM_CMD_WRITE_LOCK_BITS_gc ; Prepare NVM command in R20.
   20264:	48 e0       	ldi	r20, 0x08	; 8
	rjmp	SP_CommonCMD                    ; Jump to common NVM Action code.
   20266:	60 c0       	rjmp	.+192    	; 0x20328 <SP_CommonCMD>

00020268 <SP_ReadLockBits>:

.section .text		
.global SP_ReadLockBits

SP_ReadLockBits:
	lds	r24, NVM_LOCKBITS       ; Read IO-mapped lock bits.
   20268:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <__TEXT_REGION_LENGTH__+0x7001d0>
	ret
   2026c:	08 95       	ret

0002026e <SP_EraseUserSignatureRow>:

.section .text
.global SP_EraseUserSignatureRow

SP_EraseUserSignatureRow:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   2026e:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_USER_SIG_ROW_gc ; Prepare NVM command in R20.
   20270:	48 e1       	ldi	r20, 0x18	; 24
	jmp 	SP_CommonSPM                       ; Jump to common SPM code.
   20272:	0d 94 4e 04 	jmp	0x2089c	; 0x2089c <SP_CommonSPM>

00020276 <SP_WriteUserSignatureRow>:

.section .text
.global SP_WriteUserSignatureRow

SP_WriteUserSignatureRow:
	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
   20276:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_WRITE_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
   20278:	4a e1       	ldi	r20, 0x1A	; 26
	jmp	SP_CommonSPM                        ; Jump to common SPM code.
   2027a:	0d 94 4e 04 	jmp	0x2089c	; 0x2089c <SP_CommonSPM>

0002027e <SP_EraseApplicationSection>:

.section .text
.global SP_EraseApplicationSection

SP_EraseApplicationSection:
	in	r19, RAMPZ                 ; Save RAMPZ, which is restored in SP_CommonSPM.
   2027e:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_APP_gc  ; Prepare NVM command in R20.
   20280:	40 e2       	ldi	r20, 0x20	; 32
	jmp	SP_CommonSPM               ; Jump to common SPM code.
   20282:	0d 94 4e 04 	jmp	0x2089c	; 0x2089c <SP_CommonSPM>

00020286 <SP_EraseApplicationPage>:

.section .text	
.global SP_EraseApplicationPage

SP_EraseApplicationPage:
	in	r19, RAMPZ                      ; Save RAMPZ, which is restored in SP_CommonSPM.
   20286:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                      ; Load RAMPZ with the MSB of the address.
   20288:	8b bf       	out	0x3b, r24	; 59
	movw    r24, r22                        ; Move low bytes for ZH:ZL to R25:R24
   2028a:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_APP_PAGE_gc  ; Prepare NVM command in R20.
   2028c:	42 e2       	ldi	r20, 0x22	; 34
	jmp	SP_CommonSPM                    ; Jump to common SPM code.
   2028e:	0d 94 4e 04 	jmp	0x2089c	; 0x2089c <SP_CommonSPM>

00020292 <SP_LoadFlashWord>:

.section .text
.global SP_LoadFlashWord

SP_LoadFlashWord:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   20292:	3b b7       	in	r19, 0x3b	; 59
	movw	r0, r22                            ; Prepare flash word in R1:R0.
   20294:	0b 01       	movw	r0, r22
	ldi	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
   20296:	43 e2       	ldi	r20, 0x23	; 35
	jmp	SP_CommonSPM                       ; Jump to common SPM code.
   20298:	0d 94 4e 04 	jmp	0x2089c	; 0x2089c <SP_CommonSPM>

0002029c <SP_ReadFlashPage>:
.section .text		
.global SP_ReadFlashPage

SP_ReadFlashPage:

	in	r19, RAMPZ                   ; Save RAMPZ during assembly.
   2029c:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r22                   ; Load RAMPZ with MSB of address
   2029e:	6b bf       	out	0x3b, r22	; 59
	movw    ZL, r20                      ; Load Z with Flash address.
   202a0:	fa 01       	movw	r30, r20

	out	RAMPX, r1                    ; Load RAMPX with data pointer
   202a2:	19 be       	out	0x39, r1	; 57
	movw	XL, r24                      ; Load X with data buffer address.
   202a4:	dc 01       	movw	r26, r24

	ldi	r20, NVM_CMD_NO_OPERATION_gc ; Prepare NVM command code in R20.
   202a6:	40 e0       	ldi	r20, 0x00	; 0
	sts	NVM_CMD, r20                 ; Set NVM command to No Operation so that LPM reads Flash.
   202a8:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>

#if FLASH_PAGE_SIZE > 512
	ldi	r22, ((FLASH_PAGE_SIZE/2) >> 8) ; Load R22 with byte cont high if flash page is large.
#endif	

	ldi	r21, ((FLASH_PAGE_SIZE)&0xFF)   ; Load R21 with byte count.
   202ac:	50 e0       	ldi	r21, 0x00	; 0

000202ae <SP_ReadFlashPage_1>:

SP_ReadFlashPage_1:
	elpm	r24, Z+                         ; Load Flash bytes into R18:r19
   202ae:	87 91       	elpm	r24, Z+
	elpm	r25, Z+
   202b0:	97 91       	elpm	r25, Z+
	st	X+, r24                         ; Write bytes to buffer.
   202b2:	8d 93       	st	X+, r24
	st	X+, r25
   202b4:	9d 93       	st	X+, r25

#if FLASH_PAGE_SIZE > 512
	subi	r21, 1                          ; Decrement word count.
	sbci	r22, 0
#else
	dec	r21                             ; Decrement word count.
   202b6:	5a 95       	dec	r21
#endif	

	brne	SP_ReadFlashPage_1              ; Repeat until byte count is zero.
   202b8:	d1 f7       	brne	.-12     	; 0x202ae <SP_ReadFlashPage_1>

	out	RAMPZ, r19
   202ba:	3b bf       	out	0x3b, r19	; 59
	ret
   202bc:	08 95       	ret

000202be <SP_WriteApplicationPage>:

.section .text		
.global SP_WriteApplicationPage

SP_WriteApplicationPage:
	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
   202be:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
   202c0:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
   202c2:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_WRITE_APP_PAGE_gc   ; Prepare NVM command in R20.
   202c4:	44 e2       	ldi	r20, 0x24	; 36
	jmp	SP_CommonSPM                     ; Jump to common SPM code.
   202c6:	0d 94 4e 04 	jmp	0x2089c	; 0x2089c <SP_CommonSPM>

000202ca <SP_EraseWriteApplicationPage>:

.section .text
.global SP_EraseWriteApplicationPage

SP_EraseWriteApplicationPage:
	in	r19, RAMPZ                            ; Save RAMPZ, which is restored in SP_CommonSPM.
   202ca:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                            ; Load RAMPZ with the MSB of the address.
   202cc:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                              ; Move low bytes of address to ZH:ZL from R23:R22
   202ce:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_WRITE_APP_PAGE_gc  ; Prepare NVM command in R20.
   202d0:	45 e2       	ldi	r20, 0x25	; 37
	jmp	SP_CommonSPM                          ; Jump to common SPM code.
   202d2:	0d 94 4e 04 	jmp	0x2089c	; 0x2089c <SP_CommonSPM>

000202d6 <SP_EraseFlashBuffer>:

.section .text		
.global SP_EraseFlashBuffer

SP_EraseFlashBuffer:
	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
   202d6:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
   202d8:	46 e2       	ldi	r20, 0x26	; 38
	jmp	SP_CommonSPM                        ; Jump to common SPM code.
   202da:	0d 94 4e 04 	jmp	0x2089c	; 0x2089c <SP_CommonSPM>

000202de <SP_EraseBootPage>:

.section .text		
.global SP_EraseBootPage

SP_EraseBootPage:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   202de:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                         ; Load RAMPZ with the MSB of the address.
   202e0:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                           ; Move low bytes of address to ZH:ZL from R23:R22
   202e2:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_BOOT_PAGE_gc    ; Prepare NVM command in R20.
   202e4:	4a e2       	ldi	r20, 0x2A	; 42
	jmp	SP_CommonSPM                       ; Jump to common SPM code.
   202e6:	0d 94 4e 04 	jmp	0x2089c	; 0x2089c <SP_CommonSPM>

000202ea <SP_WriteBootPage>:

.section .text		
.global SP_WriteBootPage

SP_WriteBootPage:
	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
   202ea:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
   202ec:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
   202ee:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
   202f0:	4c e2       	ldi	r20, 0x2C	; 44
	jmp	SP_CommonSPM                     ; Jump to common SPM code.
   202f2:	0d 94 4e 04 	jmp	0x2089c	; 0x2089c <SP_CommonSPM>

000202f6 <SP_EraseWriteBootPage>:

.section .text		
.global SP_EraseWriteBootPage

SP_EraseWriteBootPage:
	in	r19, RAMPZ                             ; Save RAMPZ, which is restored in SP_CommonSPM.
   202f6:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                             ; Load RAMPZ with the MSB of the address.
   202f8:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                               ; Move low bytes of address to ZH:ZL from R23:R22
   202fa:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
   202fc:	4d e2       	ldi	r20, 0x2D	; 45
	jmp	SP_CommonSPM                           ; Jump to common SPM code.
   202fe:	0d 94 4e 04 	jmp	0x2089c	; 0x2089c <SP_CommonSPM>

00020302 <SP_ApplicationCRC>:

.section .text	
.global SP_ApplicationCRC

SP_ApplicationCRC:
	ldi	r20, NVM_CMD_APP_CRC_gc    ; Prepare NVM command in R20.
   20302:	48 e3       	ldi	r20, 0x38	; 56
	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
   20304:	11 c0       	rjmp	.+34     	; 0x20328 <SP_CommonCMD>

00020306 <SP_BootCRC>:

.section .text
.global SP_BootCRC

SP_BootCRC:
	ldi	r20, NVM_CMD_BOOT_CRC_gc   ; Prepare NVM command in R20.
   20306:	49 e3       	ldi	r20, 0x39	; 57
	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
   20308:	0f c0       	rjmp	.+30     	; 0x20328 <SP_CommonCMD>

0002030a <SP_LockSPM>:

.section .text
.global SP_LockSPM

SP_LockSPM:
	ldi	r18, CCP_IOREG_gc     ; Prepare Protect IO-register signature in R18.
   2030a:	28 ed       	ldi	r18, 0xD8	; 216
	sts	CCP, r18              ; Enable IO-register operation (this disables interrupts for 4 cycles).
   2030c:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	ldi	r18, NVM_SPMLOCK_bm   ; Prepare bitmask for locking SPM into R18.
   20310:	21 e0       	ldi	r18, 0x01	; 1
	sts	NVM_CTRLB, r18        ; Load bitmask into NVM Control Register B, which locks SPM.
   20312:	20 93 cc 01 	sts	0x01CC, r18	; 0x8001cc <__TEXT_REGION_LENGTH__+0x7001cc>
	ret
   20316:	08 95       	ret

00020318 <SP_WaitForSPM>:

.section .text
.global SP_WaitForSPM		

SP_WaitForSPM:
	lds	r18, NVM_STATUS     ; Load the NVM Status register.
   20318:	20 91 cf 01 	lds	r18, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7001cf>
	sbrc	r18, NVM_NVMBUSY_bp ; Check if bit is cleared.
   2031c:	27 fd       	sbrc	r18, 7
	rjmp	SP_WaitForSPM       ; Repeat check if bit is not cleared.
   2031e:	fc cf       	rjmp	.-8      	; 0x20318 <SP_WaitForSPM>
	clr	r18
   20320:	22 27       	eor	r18, r18
	sts	NVM_CMD, r18        ; Clear up command register to NO_OPERATION.
   20322:	20 93 ca 01 	sts	0x01CA, r18	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	ret
   20326:	08 95       	ret

00020328 <SP_CommonCMD>:
; ---

.section .text		

SP_CommonCMD:
	sts	NVM_CMD, r20        ; Load command into NVM Command register.
   20328:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	ldi	r18, CCP_IOREG_gc   ; Prepare Protect IO-register signature in R18.
   2032c:	28 ed       	ldi	r18, 0xD8	; 216
	ldi	r19, NVM_CMDEX_bm   ; Prepare bitmask for setting NVM Command Execute bit into R19.
   2032e:	31 e0       	ldi	r19, 0x01	; 1
	sts	CCP, r18            ; Enable IO-register operation (this disables interrupts for 4 cycles).
   20330:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	sts	NVM_CTRLA, r19      ; Load bitmask into NVM Control Register A, which executes the command.
   20334:	30 93 cb 01 	sts	0x01CB, r19	; 0x8001cb <__TEXT_REGION_LENGTH__+0x7001cb>
	lds	r22, NVM_DATA0      ; Load NVM Data Register 0 into R22.
   20338:	60 91 c4 01 	lds	r22, 0x01C4	; 0x8001c4 <__TEXT_REGION_LENGTH__+0x7001c4>
	lds	r23, NVM_DATA1      ; Load NVM Data Register 1 into R23.
   2033c:	70 91 c5 01 	lds	r23, 0x01C5	; 0x8001c5 <__TEXT_REGION_LENGTH__+0x7001c5>
	lds	r24, NVM_DATA2      ; Load NVM Data Register 2 into R24.
   20340:	80 91 c6 01 	lds	r24, 0x01C6	; 0x8001c6 <__TEXT_REGION_LENGTH__+0x7001c6>
	clr	r25                 ; Clear R25 in order to return a clean 32-bit value.
   20344:	99 27       	eor	r25, r25
	ret
   20346:	08 95       	ret

00020348 <SP_CommonLPM>:
; ---

.section .text		

SP_CommonLPM:
	movw	ZL, r24             ; Load index into Z.
   20348:	fc 01       	movw	r30, r24
	sts	NVM_CMD, r20        ; Load prepared command into NVM Command register.
   2034a:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm	r24,Z
   2034e:	84 91       	lpm	r24, Z
	ret
   20350:	08 95       	ret

00020352 <_ZN7CSerial13RecievedblockEPhi>:
    else
    {
	    TWIC_MASTER_CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    }
    return byte;
}
   20352:	ef 92       	push	r14
   20354:	ff 92       	push	r15
   20356:	0f 93       	push	r16
   20358:	1f 93       	push	r17
   2035a:	cf 93       	push	r28
   2035c:	df 93       	push	r29
   2035e:	14 16       	cp	r1, r20
   20360:	15 06       	cpc	r1, r21
   20362:	94 f4       	brge	.+36     	; 0x20388 <_ZN7CSerial13RecievedblockEPhi+0x36>
   20364:	8b 01       	movw	r16, r22
   20366:	7c 01       	movw	r14, r24
   20368:	eb 01       	movw	r28, r22
   2036a:	04 0f       	add	r16, r20
   2036c:	15 1f       	adc	r17, r21
   2036e:	be 01       	movw	r22, r28
   20370:	c7 01       	movw	r24, r14
   20372:	0f 94 e9 01 	call	0x203d2	; 0x203d2 <_ZN7CSerial12RecievedcharERh>
   20376:	00 97       	sbiw	r24, 0x00	; 0
   20378:	49 f0       	breq	.+18     	; 0x2038c <_ZN7CSerial13RecievedblockEPhi+0x3a>
   2037a:	21 96       	adiw	r28, 0x01	; 1
   2037c:	c0 17       	cp	r28, r16
   2037e:	d1 07       	cpc	r29, r17
   20380:	b1 f7       	brne	.-20     	; 0x2036e <_ZN7CSerial13RecievedblockEPhi+0x1c>
   20382:	81 e0       	ldi	r24, 0x01	; 1
   20384:	90 e0       	ldi	r25, 0x00	; 0
   20386:	02 c0       	rjmp	.+4      	; 0x2038c <_ZN7CSerial13RecievedblockEPhi+0x3a>
   20388:	81 e0       	ldi	r24, 0x01	; 1
   2038a:	90 e0       	ldi	r25, 0x00	; 0
   2038c:	df 91       	pop	r29
   2038e:	cf 91       	pop	r28
   20390:	1f 91       	pop	r17
   20392:	0f 91       	pop	r16
   20394:	ff 90       	pop	r15
   20396:	ef 90       	pop	r14
   20398:	08 95       	ret

0002039a <_ZN7CSerial13TransmitBlockEPhi>:
   2039a:	ef 92       	push	r14
   2039c:	ff 92       	push	r15
   2039e:	0f 93       	push	r16
   203a0:	1f 93       	push	r17
   203a2:	cf 93       	push	r28
   203a4:	df 93       	push	r29
   203a6:	14 16       	cp	r1, r20
   203a8:	15 06       	cpc	r1, r21
   203aa:	64 f4       	brge	.+24     	; 0x203c4 <_ZN7CSerial13TransmitBlockEPhi+0x2a>
   203ac:	8b 01       	movw	r16, r22
   203ae:	7c 01       	movw	r14, r24
   203b0:	eb 01       	movw	r28, r22
   203b2:	04 0f       	add	r16, r20
   203b4:	15 1f       	adc	r17, r21
   203b6:	69 91       	ld	r22, Y+
   203b8:	c7 01       	movw	r24, r14
   203ba:	0f 94 23 02 	call	0x20446	; 0x20446 <_ZN7CSerial8SendcharEh>
   203be:	c0 17       	cp	r28, r16
   203c0:	d1 07       	cpc	r29, r17
   203c2:	c9 f7       	brne	.-14     	; 0x203b6 <_ZN7CSerial13TransmitBlockEPhi+0x1c>
   203c4:	df 91       	pop	r29
   203c6:	cf 91       	pop	r28
   203c8:	1f 91       	pop	r17
   203ca:	0f 91       	pop	r16
   203cc:	ff 90       	pop	r15
   203ce:	ef 90       	pop	r14
   203d0:	08 95       	ret

000203d2 <_ZN7CSerial12RecievedcharERh>:
   203d2:	cf 93       	push	r28
   203d4:	df 93       	push	r29
   203d6:	00 d0       	rcall	.+0      	; 0x203d8 <_ZN7CSerial12RecievedcharERh+0x6>
   203d8:	00 d0       	rcall	.+0      	; 0x203da <_ZN7CSerial12RecievedcharERh+0x8>
   203da:	cd b7       	in	r28, 0x3d	; 61
   203dc:	de b7       	in	r29, 0x3e	; 62
   203de:	8b 83       	std	Y+3, r24	; 0x03
   203e0:	9c 83       	std	Y+4, r25	; 0x04
   203e2:	6d 83       	std	Y+5, r22	; 0x05
   203e4:	7e 83       	std	Y+6, r23	; 0x06
   203e6:	19 82       	std	Y+1, r1	; 0x01
   203e8:	1a 82       	std	Y+2, r1	; 0x02
   203ea:	8b 81       	ldd	r24, Y+3	; 0x03
   203ec:	9c 81       	ldd	r25, Y+4	; 0x04
   203ee:	fc 01       	movw	r30, r24
   203f0:	80 81       	ld	r24, Z
   203f2:	91 81       	ldd	r25, Z+1	; 0x01
   203f4:	fc 01       	movw	r30, r24
   203f6:	81 81       	ldd	r24, Z+1	; 0x01
   203f8:	80 95       	com	r24
   203fa:	88 1f       	adc	r24, r24
   203fc:	88 27       	eor	r24, r24
   203fe:	88 1f       	adc	r24, r24
   20400:	88 23       	and	r24, r24
   20402:	71 f0       	breq	.+28     	; 0x20420 <_ZN7CSerial12RecievedcharERh+0x4e>
   20404:	89 81       	ldd	r24, Y+1	; 0x01
   20406:	9a 81       	ldd	r25, Y+2	; 0x02
   20408:	84 33       	cpi	r24, 0x34	; 52
   2040a:	98 40       	sbci	r25, 0x08	; 8
   2040c:	19 f4       	brne	.+6      	; 0x20414 <_ZN7CSerial12RecievedcharERh+0x42>
   2040e:	80 e0       	ldi	r24, 0x00	; 0
   20410:	90 e0       	ldi	r25, 0x00	; 0
   20412:	13 c0       	rjmp	.+38     	; 0x2043a <_ZN7CSerial12RecievedcharERh+0x68>
   20414:	89 81       	ldd	r24, Y+1	; 0x01
   20416:	9a 81       	ldd	r25, Y+2	; 0x02
   20418:	01 96       	adiw	r24, 0x01	; 1
   2041a:	89 83       	std	Y+1, r24	; 0x01
   2041c:	9a 83       	std	Y+2, r25	; 0x02
   2041e:	e5 cf       	rjmp	.-54     	; 0x203ea <_ZN7CSerial12RecievedcharERh+0x18>
   20420:	8b 81       	ldd	r24, Y+3	; 0x03
   20422:	9c 81       	ldd	r25, Y+4	; 0x04
   20424:	fc 01       	movw	r30, r24
   20426:	80 81       	ld	r24, Z
   20428:	91 81       	ldd	r25, Z+1	; 0x01
   2042a:	fc 01       	movw	r30, r24
   2042c:	20 81       	ld	r18, Z
   2042e:	8d 81       	ldd	r24, Y+5	; 0x05
   20430:	9e 81       	ldd	r25, Y+6	; 0x06
   20432:	fc 01       	movw	r30, r24
   20434:	20 83       	st	Z, r18
   20436:	81 e0       	ldi	r24, 0x01	; 1
   20438:	90 e0       	ldi	r25, 0x00	; 0
   2043a:	26 96       	adiw	r28, 0x06	; 6
   2043c:	cd bf       	out	0x3d, r28	; 61
   2043e:	de bf       	out	0x3e, r29	; 62
   20440:	df 91       	pop	r29
   20442:	cf 91       	pop	r28
   20444:	08 95       	ret

00020446 <_ZN7CSerial8SendcharEh>:
   20446:	dc 01       	movw	r26, r24
   20448:	ed 91       	ld	r30, X+
   2044a:	fc 91       	ld	r31, X
   2044c:	81 81       	ldd	r24, Z+1	; 0x01
   2044e:	85 ff       	sbrs	r24, 5
   20450:	fd cf       	rjmp	.-6      	; 0x2044c <_ZN7CSerial8SendcharEh+0x6>
   20452:	60 83       	st	Z, r22
   20454:	08 95       	ret

00020456 <_ZN4CPin10shim10n100Ev>:
   20456:	fc 01       	movw	r30, r24
   20458:	a0 81       	ld	r26, Z
   2045a:	b1 81       	ldd	r27, Z+1	; 0x01
   2045c:	82 81       	ldd	r24, Z+2	; 0x02
   2045e:	15 96       	adiw	r26, 0x05	; 5
   20460:	8c 93       	st	X, r24
   20462:	8a e6       	ldi	r24, 0x6A	; 106
   20464:	8a 95       	dec	r24
   20466:	f1 f7       	brne	.-4      	; 0x20464 <_ZN4CPin10shim10n100Ev+0xe>
   20468:	00 c0       	rjmp	.+0      	; 0x2046a <_ZN4CPin10shim10n100Ev+0x14>
   2046a:	a0 81       	ld	r26, Z
   2046c:	b1 81       	ldd	r27, Z+1	; 0x01
   2046e:	82 81       	ldd	r24, Z+2	; 0x02
   20470:	16 96       	adiw	r26, 0x06	; 6
   20472:	8c 93       	st	X, r24
   20474:	8f e1       	ldi	r24, 0x1F	; 31
   20476:	93 e0       	ldi	r25, 0x03	; 3
   20478:	01 97       	sbiw	r24, 0x01	; 1
   2047a:	f1 f7       	brne	.-4      	; 0x20478 <_ZN4CPin10shim10n100Ev+0x22>
   2047c:	00 c0       	rjmp	.+0      	; 0x2047e <_ZN4CPin10shim10n100Ev+0x28>
   2047e:	00 00       	nop
   20480:	08 95       	ret

00020482 <_ZN4CPin8PullDownEv>:
   20482:	fc 01       	movw	r30, r24
   20484:	82 81       	ldd	r24, Z+2	; 0x02
   20486:	93 81       	ldd	r25, Z+3	; 0x03
   20488:	89 2b       	or	r24, r25
   2048a:	29 f4       	brne	.+10     	; 0x20496 <_ZN4CPin8PullDownEv+0x14>
   2048c:	a0 81       	ld	r26, Z
   2048e:	b1 81       	ldd	r27, Z+1	; 0x01
   20490:	80 e1       	ldi	r24, 0x10	; 16
   20492:	50 96       	adiw	r26, 0x10	; 16
   20494:	8c 93       	st	X, r24
   20496:	82 81       	ldd	r24, Z+2	; 0x02
   20498:	93 81       	ldd	r25, Z+3	; 0x03
   2049a:	01 97       	sbiw	r24, 0x01	; 1
   2049c:	29 f4       	brne	.+10     	; 0x204a8 <_ZN4CPin8PullDownEv+0x26>
   2049e:	a0 81       	ld	r26, Z
   204a0:	b1 81       	ldd	r27, Z+1	; 0x01
   204a2:	80 e1       	ldi	r24, 0x10	; 16
   204a4:	51 96       	adiw	r26, 0x11	; 17
   204a6:	8c 93       	st	X, r24
   204a8:	82 81       	ldd	r24, Z+2	; 0x02
   204aa:	93 81       	ldd	r25, Z+3	; 0x03
   204ac:	02 97       	sbiw	r24, 0x02	; 2
   204ae:	29 f4       	brne	.+10     	; 0x204ba <_ZN4CPin8PullDownEv+0x38>
   204b0:	a0 81       	ld	r26, Z
   204b2:	b1 81       	ldd	r27, Z+1	; 0x01
   204b4:	80 e1       	ldi	r24, 0x10	; 16
   204b6:	52 96       	adiw	r26, 0x12	; 18
   204b8:	8c 93       	st	X, r24
   204ba:	82 81       	ldd	r24, Z+2	; 0x02
   204bc:	93 81       	ldd	r25, Z+3	; 0x03
   204be:	03 97       	sbiw	r24, 0x03	; 3
   204c0:	29 f4       	brne	.+10     	; 0x204cc <_ZN4CPin8PullDownEv+0x4a>
   204c2:	a0 81       	ld	r26, Z
   204c4:	b1 81       	ldd	r27, Z+1	; 0x01
   204c6:	80 e1       	ldi	r24, 0x10	; 16
   204c8:	53 96       	adiw	r26, 0x13	; 19
   204ca:	8c 93       	st	X, r24
   204cc:	82 81       	ldd	r24, Z+2	; 0x02
   204ce:	93 81       	ldd	r25, Z+3	; 0x03
   204d0:	04 97       	sbiw	r24, 0x04	; 4
   204d2:	29 f4       	brne	.+10     	; 0x204de <_ZN4CPin8PullDownEv+0x5c>
   204d4:	a0 81       	ld	r26, Z
   204d6:	b1 81       	ldd	r27, Z+1	; 0x01
   204d8:	80 e1       	ldi	r24, 0x10	; 16
   204da:	54 96       	adiw	r26, 0x14	; 20
   204dc:	8c 93       	st	X, r24
   204de:	82 81       	ldd	r24, Z+2	; 0x02
   204e0:	93 81       	ldd	r25, Z+3	; 0x03
   204e2:	05 97       	sbiw	r24, 0x05	; 5
   204e4:	29 f4       	brne	.+10     	; 0x204f0 <_ZN4CPin8PullDownEv+0x6e>
   204e6:	01 90       	ld	r0, Z+
   204e8:	f0 81       	ld	r31, Z
   204ea:	e0 2d       	mov	r30, r0
   204ec:	80 e1       	ldi	r24, 0x10	; 16
   204ee:	85 8b       	std	Z+21, r24	; 0x15
   204f0:	08 95       	ret

000204f2 <_ZN4CPin5OnPinEv>:
   204f2:	dc 01       	movw	r26, r24
   204f4:	ed 91       	ld	r30, X+
   204f6:	fc 91       	ld	r31, X
   204f8:	11 97       	sbiw	r26, 0x01	; 1
   204fa:	20 85       	ldd	r18, Z+8	; 0x08
   204fc:	30 e0       	ldi	r19, 0x00	; 0
   204fe:	12 96       	adiw	r26, 0x02	; 2
   20500:	8d 91       	ld	r24, X+
   20502:	9c 91       	ld	r25, X
   20504:	13 97       	sbiw	r26, 0x03	; 3
   20506:	28 23       	and	r18, r24
   20508:	39 23       	and	r19, r25
   2050a:	81 e0       	ldi	r24, 0x01	; 1
   2050c:	23 2b       	or	r18, r19
   2050e:	09 f4       	brne	.+2      	; 0x20512 <_ZN4CPin5OnPinEv+0x20>
   20510:	80 e0       	ldi	r24, 0x00	; 0
   20512:	08 95       	ret

00020514 <_Z8exitbootv>:
bool end_of_flashing;
void exitboot();

void exitboot(){
	void (*gotozero)() = 0x0000;
	cli();
   20514:	f8 94       	cli
	SP_WaitForSPM();
   20516:	0f 94 8c 01 	call	0x20318	; 0x20318 <SP_WaitForSPM>
	SP_LockSPM();
   2051a:	0f 94 85 01 	call	0x2030a	; 0x2030a <SP_LockSPM>
	USARTD1_CTRLA = USART_RXCINTLVL_OFF_gc;
   2051e:	10 92 b3 09 	sts	0x09B3, r1	; 0x8009b3 <__TEXT_REGION_LENGTH__+0x7009b3>
	EIND = 0x00;
   20522:	1c be       	out	0x3c, r1	; 60
	gotozero();
   20524:	e0 e0       	ldi	r30, 0x00	; 0
   20526:	f0 e0       	ldi	r31, 0x00	; 0
   20528:	19 95       	eicall
   2052a:	08 95       	ret

0002052c <main>:
}

 int main(void) 
{   
   2052c:	cf 93       	push	r28
   2052e:	df 93       	push	r29
   20530:	cd b7       	in	r28, 0x3d	; 61
   20532:	de b7       	in	r29, 0x3e	; 62
   20534:	2c 97       	sbiw	r28, 0x0c	; 12
   20536:	cd bf       	out	0x3d, r28	; 61
   20538:	de bf       	out	0x3e, r29	; 62
class CCpu
{
     public:
     CCpu(){
	 //----------------InitCPU
	 OSC_CTRL = (1<<OSC_RC32MEN_bp);//разрешаем работу внутреннего тактового генератора 32MHz
   2053a:	82 e0       	ldi	r24, 0x02	; 2
   2053c:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
	 while(!(OSC_STATUS & (1<<OSC_RC32MRDY_bp))); // Ожидание готовности внутреннего тактового генератора 32MHz;
   20540:	e1 e5       	ldi	r30, 0x51	; 81
   20542:	f0 e0       	ldi	r31, 0x00	; 0
   20544:	80 81       	ld	r24, Z
   20546:	81 ff       	sbrs	r24, 1
   20548:	fd cf       	rjmp	.-6      	; 0x20544 <main+0x18>
	 CCP = 0xD8; //Разрешение записи в защищённый регистр
   2054a:	28 ed       	ldi	r18, 0xD8	; 216
   2054c:	24 bf       	out	0x34, r18	; 52
	 CLK_CTRL = 1;
   2054e:	91 e0       	ldi	r25, 0x01	; 1
   20550:	90 93 40 00 	sts	0x0040, r25	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
class CInterrupt
{
    public:
	CInterrupt(){}
	CInterrupt(int usesection){
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm ;// активация контроллера прерываний 10 bytes PM
   20554:	e0 ea       	ldi	r30, 0xA0	; 160
   20556:	f0 e0       	ldi	r31, 0x00	; 0
   20558:	82 81       	ldd	r24, Z+2	; 0x02
   2055a:	87 60       	ori	r24, 0x07	; 7
   2055c:	82 83       	std	Z+2, r24	; 0x02
	if(usesection == Boot)
	{
	      CCP = CCP_IOREG_gc; //Разрешение записи в защищённый регистр
   2055e:	24 bf       	out	0x34, r18	; 52
	      PMIC.CTRL |= PMIC_IVSEL_bm;  // активация таблицы прерываний загрузочного сектора
   20560:	82 81       	ldd	r24, Z+2	; 0x02
   20562:	80 64       	ori	r24, 0x40	; 64
   20564:	82 83       	std	Z+2, r24	; 0x02
     int pin;
  public: 
      

       CPin(PORT_t *port,int pinnum,int direct){
	   portn = port;
   20566:	e0 e2       	ldi	r30, 0x20	; 32
   20568:	f7 e0       	ldi	r31, 0x07	; 7
   2056a:	e9 83       	std	Y+1, r30	; 0x01
   2056c:	fa 83       	std	Y+2, r31	; 0x02
	   pin = pinnum;
   2056e:	21 e0       	ldi	r18, 0x01	; 1
   20570:	30 e0       	ldi	r19, 0x00	; 0
   20572:	2b 83       	std	Y+3, r18	; 0x03
   20574:	3c 83       	std	Y+4, r19	; 0x04
	   if(direct)
	   port->DIRSET = pinnum;
   20576:	91 83       	std	Z+1, r25	; 0x01
     int pin;
  public: 
      

       CPin(PORT_t *port,int pinnum,int direct){
	   portn = port;
   20578:	a0 ec       	ldi	r26, 0xC0	; 192
   2057a:	b7 e0       	ldi	r27, 0x07	; 7
   2057c:	ad 83       	std	Y+5, r26	; 0x05
   2057e:	be 83       	std	Y+6, r27	; 0x06
	   pin = pinnum;
   20580:	84 e0       	ldi	r24, 0x04	; 4
   20582:	90 e0       	ldi	r25, 0x00	; 0
   20584:	8f 83       	std	Y+7, r24	; 0x07
   20586:	98 87       	std	Y+8, r25	; 0x08
	   if(direct)
	   port->DIRSET = pinnum;
   20588:	11 96       	adiw	r26, 0x01	; 1
   2058a:	8c 93       	st	X, r24
     int pin;
  public: 
      

       CPin(PORT_t *port,int pinnum,int direct){
	   portn = port;
   2058c:	e9 87       	std	Y+9, r30	; 0x09
   2058e:	fa 87       	std	Y+10, r31	; 0x0a
	   pin = pinnum;
   20590:	80 e2       	ldi	r24, 0x20	; 32
   20592:	90 e0       	ldi	r25, 0x00	; 0
   20594:	8b 87       	std	Y+11, r24	; 0x0b
   20596:	9c 87       	std	Y+12, r25	; 0x0c
	CSerial(int rate,int device)
	{
		if(device == microe793)
		{
			port = &USARTC0;//port C0 is used
			if(rate == bdrate19200 || rate == bdrate200000){USARTC0_BAUDCTRLB = 0;USARTC0_BAUDCTRLA = rate;}
   20598:	10 92 a7 08 	sts	0x08A7, r1	; 0x8008a7 <__TEXT_REGION_LENGTH__+0x7008a7>
   2059c:	89 e0       	ldi	r24, 0x09	; 9
   2059e:	80 93 a6 08 	sts	0x08A6, r24	; 0x8008a6 <__TEXT_REGION_LENGTH__+0x7008a6>
			if(rate == bdrate115200){USARTC0_BAUDCTRLB = 208; USARTC0_BAUDCTRLA = rate;}
			
			USARTC0_CTRLA = USART_RXCINTLVL_MED_gc; //подключение прерываний
   205a2:	80 e2       	ldi	r24, 0x20	; 32
   205a4:	80 93 a3 08 	sts	0x08A3, r24	; 0x8008a3 <__TEXT_REGION_LENGTH__+0x7008a3>
			USARTC0_CTRLC = USART_CHSIZE_8BIT_gc; //8 data bits, no parity and 1 stop bit
   205a8:	83 e0       	ldi	r24, 0x03	; 3
   205aa:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <__TEXT_REGION_LENGTH__+0x7008a5>
			USARTC0_CTRLB = USART_TXEN_bm | USART_RXEN_bm; //Включение приема передатчика
   205ae:	88 e1       	ldi	r24, 0x18	; 24
   205b0:	80 93 a4 08 	sts	0x08A4, r24	; 0x8008a4 <__TEXT_REGION_LENGTH__+0x7008a4>
			PORTC.DIRSET = PIN3_bm;  // настройка ноги 3 порта С контроллера Xmega на выход!для передачи данных в микросхему Uart
   205b4:	88 e0       	ldi	r24, 0x08	; 8
   205b6:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>

public:
    CTwi(){}
	CTwi(int speed){
	//----------------InitTWI
	TWIC.CTRL = 0;
   205ba:	10 92 80 04 	sts	0x0480, r1	; 0x800480 <__TEXT_REGION_LENGTH__+0x700480>
	TWIC_MASTER_BAUD=speed;// При 32 Мгц, на 100кГц = 155(0x9B)
   205be:	9b e9       	ldi	r25, 0x9B	; 155
   205c0:	90 93 85 04 	sts	0x0485, r25	; 0x800485 <__TEXT_REGION_LENGTH__+0x700485>
	TWIC_MASTER_CTRLA=TWI_MASTER_ENABLE_bm; //enable master
   205c4:	80 93 81 04 	sts	0x0481, r24	; 0x800481 <__TEXT_REGION_LENGTH__+0x700481>
	TWIC_MASTER_CTRLB=0x00; //disable Inactive Bus Timeout, disable QCEN and SMEN
   205c8:	10 92 82 04 	sts	0x0482, r1	; 0x800482 <__TEXT_REGION_LENGTH__+0x700482>
	TWIC_MASTER_CTRLC=0x00; //send ACK and NOACT initially
   205cc:	10 92 83 04 	sts	0x0483, r1	; 0x800483 <__TEXT_REGION_LENGTH__+0x700483>
	TWIC_MASTER_STATUS=TWI_MASTER_RIF_bm|TWI_MASTER_WIF_bm|TWI_MASTER_ARBLOST_bm|TWI_MASTER_BUSERR_bm|TWI_MASTER_BUSSTATE0_bm; //initially clear all flags and select bus state as IDLE
   205d0:	8d ec       	ldi	r24, 0xCD	; 205
   205d2:	80 93 84 04 	sts	0x0484, r24	; 0x800484 <__TEXT_REGION_LENGTH__+0x700484>
   //CSerial       InitUart(bdrate200000,lir540);
   CTwi          InitTwi(Twi100Khz);
   //CRtc          rtc(793);
 
   
   pin5portK.PullDown();
   205d6:	ce 01       	movw	r24, r28
   205d8:	09 96       	adiw	r24, 0x09	; 9
   205da:	0f 94 41 02 	call	0x20482	; 0x20482 <_ZN4CPin8PullDownEv>
	void disable();
};

void CInterrupt::enable()
{
     sei();
   205de:	78 94       	sei
             
   inter.enable();
   
    while (1) 
    { 	 
	   pin0portK.shim10n100();
   205e0:	ce 01       	movw	r24, r28
   205e2:	01 96       	adiw	r24, 0x01	; 1
   205e4:	0f 94 2b 02 	call	0x20456	; 0x20456 <_ZN4CPin10shim10n100Ev>
	   

	    if(pin5portK.OnPin()) // || Onboot
   205e8:	ce 01       	movw	r24, r28
   205ea:	09 96       	adiw	r24, 0x09	; 9
   205ec:	0f 94 79 02 	call	0x204f2	; 0x204f2 <_ZN4CPin5OnPinEv>
	    {
		    Onboot = true;					
	    }
	    if(!pin5portK.OnPin() || end_of_flashing)
   205f0:	ce 01       	movw	r24, r28
   205f2:	09 96       	adiw	r24, 0x09	; 9
   205f4:	0f 94 79 02 	call	0x204f2	; 0x204f2 <_ZN4CPin5OnPinEv>
   205f8:	88 23       	and	r24, r24
   205fa:	21 f0       	breq	.+8      	; 0x20604 <main+0xd8>
   205fc:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <_edata>
   20600:	88 23       	and	r24, r24
   20602:	71 f3       	breq	.-36     	; 0x205e0 <main+0xb4>
}


void CPin::outclr()
{
    portn->OUTCLR = pin; 
   20604:	e9 81       	ldd	r30, Y+1	; 0x01
   20606:	fa 81       	ldd	r31, Y+2	; 0x02
   20608:	8b 81       	ldd	r24, Y+3	; 0x03
   2060a:	86 83       	std	Z+6, r24	; 0x06
	    {
		    pin0portK.outclr();
			pin2portQ.shim10n100();
   2060c:	ce 01       	movw	r24, r28
   2060e:	05 96       	adiw	r24, 0x05	; 5
   20610:	0f 94 2b 02 	call	0x20456	; 0x20456 <_ZN4CPin10shim10n100Ev>
		    exitboot();
   20614:	0f 94 8a 02 	call	0x20514	; 0x20514 <_Z8exitbootv>
   20618:	e3 cf       	rjmp	.-58     	; 0x205e0 <main+0xb4>

0002061a <__vector_10>:
	    }
    }
}

ISR(RTC_OVF_vect)
{
   2061a:	1f 92       	push	r1
   2061c:	0f 92       	push	r0
   2061e:	0f b6       	in	r0, 0x3f	; 63
   20620:	0f 92       	push	r0
   20622:	11 24       	eor	r1, r1
   20624:	08 b6       	in	r0, 0x38	; 56
   20626:	0f 92       	push	r0
   20628:	18 be       	out	0x38, r1	; 56
   2062a:	09 b6       	in	r0, 0x39	; 57
   2062c:	0f 92       	push	r0
   2062e:	19 be       	out	0x39, r1	; 57
   20630:	0b b6       	in	r0, 0x3b	; 59
   20632:	0f 92       	push	r0
   20634:	1b be       	out	0x3b, r1	; 59
   20636:	8f 93       	push	r24
   20638:	af 93       	push	r26
   2063a:	bf 93       	push	r27
   2063c:	ef 93       	push	r30
   2063e:	ff 93       	push	r31

       CPin(PORT_t *port,int pinnum,int direct){
	   portn = port;
	   pin = pinnum;
	   if(direct)
	   port->DIRSET = pinnum;
   20640:	e0 e2       	ldi	r30, 0x20	; 32
   20642:	f7 e0       	ldi	r31, 0x07	; 7
   20644:	84 e0       	ldi	r24, 0x04	; 4
   20646:	81 83       	std	Z+1, r24	; 0x01
	   bool OnPin();                       // 80 bytes PM
};

 void CPin::outset()
{
    portn->OUTSET = pin;
   20648:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
   2064a:	af e2       	ldi	r26, 0x2F	; 47
   2064c:	b2 e0       	ldi	r27, 0x02	; 2
   2064e:	11 97       	sbiw	r26, 0x01	; 1
   20650:	f1 f7       	brne	.-4      	; 0x2064e <__vector_10+0x34>
   20652:	00 c0       	rjmp	.+0      	; 0x20654 <__vector_10+0x3a>
   20654:	00 00       	nop
}


void CPin::outclr()
{
    portn->OUTCLR = pin; 
   20656:	86 83       	std	Z+6, r24	; 0x06
	_delay_us(70);

	pin2portK.outclr();
	//_delay_ms(5);
	
}
   20658:	ff 91       	pop	r31
   2065a:	ef 91       	pop	r30
   2065c:	bf 91       	pop	r27
   2065e:	af 91       	pop	r26
   20660:	8f 91       	pop	r24
   20662:	0f 90       	pop	r0
   20664:	0b be       	out	0x3b, r0	; 59
   20666:	0f 90       	pop	r0
   20668:	09 be       	out	0x39, r0	; 57
   2066a:	0f 90       	pop	r0
   2066c:	08 be       	out	0x38, r0	; 56
   2066e:	0f 90       	pop	r0
   20670:	0f be       	out	0x3f, r0	; 63
   20672:	0f 90       	pop	r0
   20674:	1f 90       	pop	r1
   20676:	18 95       	reti

00020678 <__vector_25>:

ISR(USARTC0_RXC_vect)
{
   20678:	1f 92       	push	r1
   2067a:	0f 92       	push	r0
   2067c:	0f b6       	in	r0, 0x3f	; 63
   2067e:	0f 92       	push	r0
   20680:	11 24       	eor	r1, r1
   20682:	08 b6       	in	r0, 0x38	; 56
   20684:	0f 92       	push	r0
   20686:	18 be       	out	0x38, r1	; 56
   20688:	09 b6       	in	r0, 0x39	; 57
   2068a:	0f 92       	push	r0
   2068c:	19 be       	out	0x39, r1	; 57
   2068e:	0a b6       	in	r0, 0x3a	; 58
   20690:	0f 92       	push	r0
   20692:	1a be       	out	0x3a, r1	; 58
   20694:	0b b6       	in	r0, 0x3b	; 59
   20696:	0f 92       	push	r0
   20698:	1b be       	out	0x3b, r1	; 59
   2069a:	8f 92       	push	r8
   2069c:	9f 92       	push	r9
   2069e:	af 92       	push	r10
   206a0:	bf 92       	push	r11
   206a2:	cf 92       	push	r12
   206a4:	df 92       	push	r13
   206a6:	ef 92       	push	r14
   206a8:	ff 92       	push	r15
   206aa:	0f 93       	push	r16
   206ac:	1f 93       	push	r17
   206ae:	2f 93       	push	r18
   206b0:	3f 93       	push	r19
   206b2:	4f 93       	push	r20
   206b4:	5f 93       	push	r21
   206b6:	6f 93       	push	r22
   206b8:	7f 93       	push	r23
   206ba:	8f 93       	push	r24
   206bc:	9f 93       	push	r25
   206be:	af 93       	push	r26
   206c0:	bf 93       	push	r27
   206c2:	ef 93       	push	r30
   206c4:	ff 93       	push	r31
   206c6:	cf 93       	push	r28
   206c8:	df 93       	push	r29
   206ca:	cd b7       	in	r28, 0x3d	; 61
   206cc:	de b7       	in	r29, 0x3e	; 62
   206ce:	c2 5c       	subi	r28, 0xC2	; 194
   206d0:	d2 40       	sbci	r29, 0x02	; 2
   206d2:	cd bf       	out	0x3d, r28	; 61
   206d4:	de bf       	out	0x3e, r29	; 62
	USART_t * port;
	public:
	CSerial(){}
	CSerial(USART_t * port_t)
	{
		port = port_t;
   206d6:	80 ea       	ldi	r24, 0xA0	; 160
   206d8:	98 e0       	ldi	r25, 0x08	; 8
   206da:	89 83       	std	Y+1, r24	; 0x01
   206dc:	9a 83       	std	Y+2, r25	; 0x02

	CSerial       uart(&USARTC0);
	CTwi          twi;
	
	unsigned char block[700] = { 0 };
   206de:	be 01       	movw	r22, r28
   206e0:	6d 5f       	subi	r22, 0xFD	; 253
   206e2:	7f 4f       	sbci	r23, 0xFF	; 255
   206e4:	8c eb       	ldi	r24, 0xBC	; 188
   206e6:	92 e0       	ldi	r25, 0x02	; 2
   206e8:	fb 01       	movw	r30, r22
   206ea:	9c 01       	movw	r18, r24
   206ec:	11 92       	st	Z+, r1
   206ee:	21 50       	subi	r18, 0x01	; 1
   206f0:	30 40       	sbci	r19, 0x00	; 0
   206f2:	e1 f7       	brne	.-8      	; 0x206ec <__vector_25+0x74>
	unsigned char answerFlash[] = { 0xff,0x02,0x04,0x0A };
   206f4:	8f ef       	ldi	r24, 0xFF	; 255
   206f6:	c1 54       	subi	r28, 0x41	; 65
   206f8:	dd 4f       	sbci	r29, 0xFD	; 253
   206fa:	88 83       	st	Y, r24
   206fc:	cf 5b       	subi	r28, 0xBF	; 191
   206fe:	d2 40       	sbci	r29, 0x02	; 2
   20700:	82 e0       	ldi	r24, 0x02	; 2
   20702:	c0 54       	subi	r28, 0x40	; 64
   20704:	dd 4f       	sbci	r29, 0xFD	; 253
   20706:	88 83       	st	Y, r24
   20708:	c0 5c       	subi	r28, 0xC0	; 192
   2070a:	d2 40       	sbci	r29, 0x02	; 2
   2070c:	84 e0       	ldi	r24, 0x04	; 4
   2070e:	cf 53       	subi	r28, 0x3F	; 63
   20710:	dd 4f       	sbci	r29, 0xFD	; 253
   20712:	88 83       	st	Y, r24
   20714:	c1 5c       	subi	r28, 0xC1	; 193
   20716:	d2 40       	sbci	r29, 0x02	; 2
   20718:	8a e0       	ldi	r24, 0x0A	; 10
   2071a:	ce 53       	subi	r28, 0x3E	; 62
   2071c:	dd 4f       	sbci	r29, 0xFD	; 253
   2071e:	88 83       	st	Y, r24
   20720:	c2 5c       	subi	r28, 0xC2	; 194
   20722:	d2 40       	sbci	r29, 0x02	; 2

	uart.Recievedblock(block,sizeof(block));
   20724:	4c eb       	ldi	r20, 0xBC	; 188
   20726:	52 e0       	ldi	r21, 0x02	; 2
   20728:	ce 01       	movw	r24, r28
   2072a:	01 96       	adiw	r24, 0x01	; 1
   2072c:	0f 94 a9 01 	call	0x20352	; 0x20352 <_ZN7CSerial13RecievedblockEPhi>
	
	if ( block[3] == WRITE_ || block[3] == 0x83)
   20730:	8e 81       	ldd	r24, Y+6	; 0x06
   20732:	83 30       	cpi	r24, 0x03	; 3
   20734:	61 f0       	breq	.+24     	; 0x2074e <__vector_25+0xd6>
   20736:	83 38       	cpi	r24, 0x83	; 131
   20738:	c1 f5       	brne	.+112    	; 0x207aa <__vector_25+0x132>
	{
		unsigned long addres_page;

		if(block[3] == 0x83)
			addres_page = 255 + (int)block[6];
   2073a:	89 84       	ldd	r8, Y+9	; 0x09
   2073c:	91 2c       	mov	r9, r1
   2073e:	3f ef       	ldi	r19, 0xFF	; 255
   20740:	83 0e       	add	r8, r19
   20742:	91 1c       	adc	r9, r1
   20744:	09 2c       	mov	r0, r9
   20746:	00 0c       	add	r0, r0
   20748:	aa 08       	sbc	r10, r10
   2074a:	bb 08       	sbc	r11, r11
   2074c:	53 c0       	rjmp	.+166    	; 0x207f4 <__vector_25+0x17c>
		else
			addres_page = (int)block[6] - 1;
   2074e:	89 84       	ldd	r8, Y+9	; 0x09
   20750:	91 2c       	mov	r9, r1
   20752:	81 e0       	ldi	r24, 0x01	; 1
   20754:	88 1a       	sub	r8, r24
   20756:	91 08       	sbc	r9, r1
   20758:	09 2c       	mov	r0, r9
   2075a:	00 0c       	add	r0, r0
   2075c:	aa 08       	sbc	r10, r10
   2075e:	bb 08       	sbc	r11, r11
   20760:	49 c0       	rjmp	.+146    	; 0x207f4 <__vector_25+0x17c>
			return;
		
		for(int x=0;x<APP_SECTION_PAGE_SIZE;x+=2)
		{
			uint16_t word;
			word = (uint8_t) block[x + 8];          //low
   20762:	f6 01       	movw	r30, r12
   20764:	00 81       	ld	r16, Z
			word |= (uint8_t) block[x + 9]<<8;      //hi
   20766:	81 81       	ldd	r24, Z+1	; 0x01
   20768:	10 e0       	ldi	r17, 0x00	; 0
   2076a:	18 2b       	or	r17, r24
			SP_WaitForSPM();
   2076c:	0f 94 8c 01 	call	0x20318	; 0x20318 <SP_WaitForSPM>
			SP_LoadFlashWord(x, word);
   20770:	b8 01       	movw	r22, r16
   20772:	c7 01       	movw	r24, r14
   20774:	0f 94 49 01 	call	0x20292	; 0x20292 <SP_LoadFlashWord>
		addres_page = addres_page * 512;

		if(addres_page >= APP_END)
			return;
		
		for(int x=0;x<APP_SECTION_PAGE_SIZE;x+=2)
   20778:	f2 e0       	ldi	r31, 0x02	; 2
   2077a:	ef 0e       	add	r14, r31
   2077c:	f1 1c       	adc	r15, r1
   2077e:	22 e0       	ldi	r18, 0x02	; 2
   20780:	c2 0e       	add	r12, r18
   20782:	d1 1c       	adc	r13, r1
   20784:	e1 14       	cp	r14, r1
   20786:	32 e0       	ldi	r19, 0x02	; 2
   20788:	f3 06       	cpc	r15, r19
   2078a:	59 f7       	brne	.-42     	; 0x20762 <__vector_25+0xea>
			word = (uint8_t) block[x + 8];          //low
			word |= (uint8_t) block[x + 9]<<8;      //hi
			SP_WaitForSPM();
			SP_LoadFlashWord(x, word);
		}
		SP_WaitForSPM();
   2078c:	0f 94 8c 01 	call	0x20318	; 0x20318 <SP_WaitForSPM>
		SP_EraseWriteApplicationPage(addres_page);
   20790:	c5 01       	movw	r24, r10
   20792:	b4 01       	movw	r22, r8
   20794:	0f 94 65 01 	call	0x202ca	; 0x202ca <SP_EraseWriteApplicationPage>

		uart.TransmitBlock(answerFlash,sizeof(answerFlash));
   20798:	44 e0       	ldi	r20, 0x04	; 4
   2079a:	50 e0       	ldi	r21, 0x00	; 0
   2079c:	be 01       	movw	r22, r28
   2079e:	61 54       	subi	r22, 0x41	; 65
   207a0:	7d 4f       	sbci	r23, 0xFD	; 253
   207a2:	ce 01       	movw	r24, r28
   207a4:	01 96       	adiw	r24, 0x01	; 1
   207a6:	0f 94 cd 01 	call	0x2039a	; 0x2039a <_ZN7CSerial13TransmitBlockEPhi>
	}


	if ( block[3] == TEST_ && block[4] == TEST_ ){ uart.TransmitBlock(block,8); }
   207aa:	8e 81       	ldd	r24, Y+6	; 0x06
   207ac:	85 35       	cpi	r24, 0x55	; 85
   207ae:	61 f4       	brne	.+24     	; 0x207c8 <__vector_25+0x150>
   207b0:	8f 81       	ldd	r24, Y+7	; 0x07
   207b2:	85 35       	cpi	r24, 0x55	; 85
   207b4:	a9 f5       	brne	.+106    	; 0x20820 <__vector_25+0x1a8>
   207b6:	48 e0       	ldi	r20, 0x08	; 8
   207b8:	50 e0       	ldi	r21, 0x00	; 0
   207ba:	be 01       	movw	r22, r28
   207bc:	6d 5f       	subi	r22, 0xFD	; 253
   207be:	7f 4f       	sbci	r23, 0xFF	; 255
   207c0:	ce 01       	movw	r24, r28
   207c2:	01 96       	adiw	r24, 0x01	; 1
   207c4:	0f 94 cd 01 	call	0x2039a	; 0x2039a <_ZN7CSerial13TransmitBlockEPhi>

	if ( block[3] == SET_TIME && block[4] == SET_TIME) { uart.TransmitBlock(block,1); }
   207c8:	8e 81       	ldd	r24, Y+6	; 0x06
   207ca:	87 30       	cpi	r24, 0x07	; 7
   207cc:	61 f4       	brne	.+24     	; 0x207e6 <__vector_25+0x16e>
   207ce:	8f 81       	ldd	r24, Y+7	; 0x07
   207d0:	87 30       	cpi	r24, 0x07	; 7
   207d2:	31 f5       	brne	.+76     	; 0x20820 <__vector_25+0x1a8>
   207d4:	41 e0       	ldi	r20, 0x01	; 1
   207d6:	50 e0       	ldi	r21, 0x00	; 0
   207d8:	be 01       	movw	r22, r28
   207da:	6d 5f       	subi	r22, 0xFD	; 253
   207dc:	7f 4f       	sbci	r23, 0xFF	; 255
   207de:	ce 01       	movw	r24, r28
   207e0:	01 96       	adiw	r24, 0x01	; 1
   207e2:	0f 94 cd 01 	call	0x2039a	; 0x2039a <_ZN7CSerial13TransmitBlockEPhi>

	if ( block[3] == WRITE_CHECK_ONES){ end_of_flashing = true;}
   207e6:	8e 81       	ldd	r24, Y+6	; 0x06
   207e8:	8c 33       	cpi	r24, 0x3C	; 60
   207ea:	d1 f4       	brne	.+52     	; 0x20820 <__vector_25+0x1a8>
   207ec:	81 e0       	ldi	r24, 0x01	; 1
   207ee:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <_edata>
   207f2:	16 c0       	rjmp	.+44     	; 0x20820 <__vector_25+0x1a8>
		if(block[3] == 0x83)
			addres_page = 255 + (int)block[6];
		else
			addres_page = (int)block[6] - 1;

		addres_page = addres_page * 512;
   207f4:	07 2e       	mov	r0, r23
   207f6:	79 e0       	ldi	r23, 0x09	; 9
   207f8:	88 0c       	add	r8, r8
   207fa:	99 1c       	adc	r9, r9
   207fc:	aa 1c       	adc	r10, r10
   207fe:	bb 1c       	adc	r11, r11
   20800:	7a 95       	dec	r23
   20802:	d1 f7       	brne	.-12     	; 0x207f8 <__vector_25+0x180>
   20804:	70 2d       	mov	r23, r0

		if(addres_page >= APP_END)
   20806:	81 14       	cp	r8, r1
   20808:	91 04       	cpc	r9, r1
   2080a:	82 e0       	ldi	r24, 0x02	; 2
   2080c:	a8 06       	cpc	r10, r24
   2080e:	b1 04       	cpc	r11, r1
   20810:	38 f4       	brcc	.+14     	; 0x20820 <__vector_25+0x1a8>
   20812:	6e 01       	movw	r12, r28
   20814:	eb e0       	ldi	r30, 0x0B	; 11
   20816:	ce 0e       	add	r12, r30
   20818:	d1 1c       	adc	r13, r1
   2081a:	e1 2c       	mov	r14, r1
   2081c:	f1 2c       	mov	r15, r1
   2081e:	a1 cf       	rjmp	.-190    	; 0x20762 <__vector_25+0xea>
	if ( block[3] == SET_TIME && block[4] == SET_TIME) { uart.TransmitBlock(block,1); }

	if ( block[3] == WRITE_CHECK_ONES){ end_of_flashing = true;}
	
	return;	
}
   20820:	ce 53       	subi	r28, 0x3E	; 62
   20822:	dd 4f       	sbci	r29, 0xFD	; 253
   20824:	cd bf       	out	0x3d, r28	; 61
   20826:	de bf       	out	0x3e, r29	; 62
   20828:	df 91       	pop	r29
   2082a:	cf 91       	pop	r28
   2082c:	ff 91       	pop	r31
   2082e:	ef 91       	pop	r30
   20830:	bf 91       	pop	r27
   20832:	af 91       	pop	r26
   20834:	9f 91       	pop	r25
   20836:	8f 91       	pop	r24
   20838:	7f 91       	pop	r23
   2083a:	6f 91       	pop	r22
   2083c:	5f 91       	pop	r21
   2083e:	4f 91       	pop	r20
   20840:	3f 91       	pop	r19
   20842:	2f 91       	pop	r18
   20844:	1f 91       	pop	r17
   20846:	0f 91       	pop	r16
   20848:	ff 90       	pop	r15
   2084a:	ef 90       	pop	r14
   2084c:	df 90       	pop	r13
   2084e:	cf 90       	pop	r12
   20850:	bf 90       	pop	r11
   20852:	af 90       	pop	r10
   20854:	9f 90       	pop	r9
   20856:	8f 90       	pop	r8
   20858:	0f 90       	pop	r0
   2085a:	0b be       	out	0x3b, r0	; 59
   2085c:	0f 90       	pop	r0
   2085e:	0a be       	out	0x3a, r0	; 58
   20860:	0f 90       	pop	r0
   20862:	09 be       	out	0x39, r0	; 57
   20864:	0f 90       	pop	r0
   20866:	08 be       	out	0x38, r0	; 56
   20868:	0f 90       	pop	r0
   2086a:	0f be       	out	0x3f, r0	; 63
   2086c:	0f 90       	pop	r0
   2086e:	1f 90       	pop	r1
   20870:	18 95       	reti

00020872 <_exit>:
   20872:	f8 94       	cli

00020874 <__stop_program>:
   20874:	ff cf       	rjmp	.-2      	; 0x20874 <__stop_program>

Disassembly of section .BOOT:

00020876 <SP_LoadFlashPage>:
		
.section .BOOT, "ax"
.global SP_LoadFlashPage

SP_LoadFlashPage:
	clr	ZL              ; Clear low byte of Z, to indicate start of page.
   20876:	ee 27       	eor	r30, r30
	clr	ZH              ; Clear high byte of Z, to indicate start of page.
   20878:	ff 27       	eor	r31, r31

	out	RAMPX, r1       ; Clear RAMPX pointer.
   2087a:	19 be       	out	0x39, r1	; 57
	movw	XL, r24         ; Load X with data buffer address.
   2087c:	dc 01       	movw	r26, r24

	ldi 	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command code in R20.
   2087e:	43 e2       	ldi	r20, 0x23	; 35
	sts	NVM_CMD, r20                       ; Load it into NVM command register.
   20880:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>

#if FLASH_PAGE_SIZE > 512
	ldi	r22, ((FLASH_PAGE_SIZE/2) >> 8)
#endif

	ldi	r21, ((FLASH_PAGE_SIZE/2)&0xFF)    ; Load R21 with page word count.
   20884:	50 e0       	ldi	r21, 0x00	; 0
	ldi	r18, CCP_SPM_gc                    ; Prepare Protect SPM signature in R16.
   20886:	2d e9       	ldi	r18, 0x9D	; 157

00020888 <SP_LoadFlashPage_1>:

SP_LoadFlashPage_1:
	ld	r0, X+         ; Load low byte from buffer into R0.
   20888:	0d 90       	ld	r0, X+
	ld	r1, X+         ; Load high byte from buffer into R1.
   2088a:	1d 90       	ld	r1, X+
	sts	CCP, r18       ; Enable SPM operation (this disables interrupts for 4 cycles).
   2088c:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	spm                    ; Self-program.
   20890:	e8 95       	spm
	adiw	ZL, 2          ; Move Z to next Flash word.
   20892:	32 96       	adiw	r30, 0x02	; 2

#if FLASH_PAGE_SIZE > 512
	subi	r21, 1         ; Decrement word count.
	sbci	r22, 0
#else
	dec	r21            ; Decrement word count.
   20894:	5a 95       	dec	r21
#endif

	brne	SP_LoadFlashPage_1   ; Repeat until word cont is zero.
   20896:	c1 f7       	brne	.-16     	; 0x20888 <SP_LoadFlashPage_1>

	clr	r1                   ; Clear R1 for GCC _zero_reg_ to function properly.
   20898:	11 24       	eor	r1, r1
	ret
   2089a:	08 95       	ret

0002089c <SP_CommonSPM>:
; ---

.section .BOOT, "ax"

SP_CommonSPM:
	movw	ZL, r24          ; Load R25:R24 into Z.
   2089c:	fc 01       	movw	r30, r24
	sts	NVM_CMD, r20     ; Load prepared command into NVM Command register.
   2089e:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	ldi	r18, CCP_SPM_gc  ; Prepare Protect SPM signature in R18
   208a2:	2d e9       	ldi	r18, 0x9D	; 157
	sts	CCP, r18         ; Enable SPM operation (this disables interrupts for 4 cycles).
   208a4:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	spm                      ; Self-program.
   208a8:	e8 95       	spm
	clr	r1               ; Clear R1 for GCC _zero_reg_ to function properly.
   208aa:	11 24       	eor	r1, r1
	out	RAMPZ, r19       ; Restore RAMPZ register.
   208ac:	3b bf       	out	0x3b, r19	; 59
	ret
   208ae:	08 95       	ret
