
testBoot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000726  00020000  00020000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .BOOT         0000003a  00020726  00020726  0000077a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         00000000  00802000  00802000  000007b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .comment      00000030  00000000  00000000  000007b4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000007e4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000f0  00000000  00000000  00000828  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000049f1  00000000  00000000  00000918  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003641  00000000  00000000  00005309  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000cef  00000000  00000000  0000894a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000240  00000000  00000000  0000963c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002d4d  00000000  00000000  0000987c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000a67  00000000  00000000  0000c5c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000118  00000000  00000000  0000d030  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00020000 <__vectors>:
   20000:	0d 94 fa 00 	jmp	0x201f4	; 0x201f4 <__ctors_end>
   20004:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20008:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2000c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20010:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20014:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20018:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2001c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20020:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20024:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20028:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2002c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20030:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20034:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20038:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2003c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20040:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20044:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20048:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2004c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20050:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20054:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20058:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2005c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20060:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20064:	0d 94 a0 02 	jmp	0x20540	; 0x20540 <__vector_25>
   20068:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2006c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20070:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20074:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20078:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2007c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20080:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20084:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20088:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2008c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20090:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20094:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20098:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2009c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200a0:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200a4:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200a8:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200ac:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200b0:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200b4:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200b8:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200bc:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200c0:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200c4:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200c8:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200cc:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200d0:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200d4:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200d8:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200dc:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200e0:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200e4:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200e8:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200ec:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200f0:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200f4:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200f8:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   200fc:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20100:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20104:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20108:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2010c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20110:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20114:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20118:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2011c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20120:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20124:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20128:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2012c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20130:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20134:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20138:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2013c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20140:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20144:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20148:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2014c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20150:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20154:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20158:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2015c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20160:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20164:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20168:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2016c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20170:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20174:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20178:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2017c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20180:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20184:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20188:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2018c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20190:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20194:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   20198:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   2019c:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201a0:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201a4:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201a8:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201ac:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201b0:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201b4:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201b8:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201bc:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201c0:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201c4:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201c8:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201cc:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201d0:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201d4:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201d8:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201dc:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201e0:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201e4:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201e8:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201ec:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>
   201f0:	0d 94 0a 01 	jmp	0x20214	; 0x20214 <__bad_interrupt>

000201f4 <__ctors_end>:
   201f4:	11 24       	eor	r1, r1
   201f6:	1f be       	out	0x3f, r1	; 63
   201f8:	cf ef       	ldi	r28, 0xFF	; 255
   201fa:	cd bf       	out	0x3d, r28	; 61
   201fc:	df e3       	ldi	r29, 0x3F	; 63
   201fe:	de bf       	out	0x3e, r29	; 62
   20200:	01 e0       	ldi	r16, 0x01	; 1
   20202:	0c bf       	out	0x3c, r16	; 60
   20204:	18 be       	out	0x38, r1	; 56
   20206:	19 be       	out	0x39, r1	; 57
   20208:	1a be       	out	0x3a, r1	; 58
   2020a:	1b be       	out	0x3b, r1	; 59
   2020c:	0f 94 44 02 	call	0x20488	; 0x20488 <main>
   20210:	0d 94 91 03 	jmp	0x20722	; 0x20722 <_exit>

00020214 <__bad_interrupt>:
   20214:	0d 94 00 00 	jmp	0x20000	; 0x20000 <__vectors>

00020218 <CCP_CLK>:
.global CCP_CLK 
.global CCP_RST

.func CCP_CLK 
    CCP_CLK: 
    ldi  r20, CCP_SIGN 
   20218:	48 ed       	ldi	r20, 0xD8	; 216
    out  CCP, r20 
   2021a:	44 bf       	out	0x34, r20	; 52
    sts  CLK_CTRL, r24 //1 uint8_t gets passed via r24
   2021c:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
ret 
   20220:	08 95       	ret

00020222 <CCP_RST>:

.endfunc 

.func CCP_RST
    CCP_RST: 
    ldi  r20, CCP_SIGN 
   20222:	48 ed       	ldi	r20, 0xD8	; 216
    out  CCP, r20 
   20224:	44 bf       	out	0x34, r20	; 52
    ldi  r20, 1
   20226:	41 e0       	ldi	r20, 0x01	; 1
    sts  RST_CTRL, r20
   20228:	40 93 79 00 	sts	0x0079, r20	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
ret 
   2022c:	08 95       	ret

0002022e <SP_ReadByte>:

.section .text
.global SP_ReadByte

SP_ReadByte:
	in	r19, RAMPZ      ; Save RAMPZ.
   2022e:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
   20230:	8b bf       	out	0x3b, r24	; 59
	movw	ZL, r22         ; Move the low bytes to the Z pointer
   20232:	fb 01       	movw	r30, r22
	elpm	r24, Z          ; Extended load byte from address pointed to by Z.
   20234:	86 91       	elpm	r24, Z
	out	RAMPZ, r19      ; Restore RAMPZ register.
   20236:	3b bf       	out	0x3b, r19	; 59
	ret
   20238:	08 95       	ret

0002023a <SP_ReadWord>:

.section .text
.global SP_ReadWord

SP_ReadWord:
	in	r19, RAMPZ      ; Save RAMPZ.
   2023a:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24      ; Load RAMPZ with the MSB of the address.
   2023c:	8b bf       	out	0x3b, r24	; 59
	movw	ZL, r22         ; Move the low bytes to the Z pointer
   2023e:	fb 01       	movw	r30, r22
	elpm	r24, Z+         ; Extended load byte from address pointed to by Z.
   20240:	87 91       	elpm	r24, Z+
	elpm	r25, Z          ; Extended load byte from address pointed to by Z.
   20242:	96 91       	elpm	r25, Z
	out	RAMPZ, r19      ; Restore RAMPZ register.
   20244:	3b bf       	out	0x3b, r19	; 59
	ret
   20246:	08 95       	ret

00020248 <SP_ReadCalibrationByte>:

.section .text
.global SP_ReadCalibrationByte	

SP_ReadCalibrationByte:
	ldi	r20, NVM_CMD_READ_CALIB_ROW_gc    ; Prepare NVM command in R20.
   20248:	42 e0       	ldi	r20, 0x02	; 2
	rjmp	SP_CommonLPM                      ; Jump to common LPM code.
   2024a:	81 c0       	rjmp	.+258    	; 0x2034e <SP_CommonLPM>

0002024c <SP_ReadUserSignatureByte>:

.section .text	
.global SP_ReadUserSignatureByte

SP_ReadUserSignatureByte:
	ldi	r20, NVM_CMD_READ_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
   2024c:	41 e0       	ldi	r20, 0x01	; 1
	rjmp	SP_CommonLPM                       ; Jump to common LPM code.
   2024e:	7f c0       	rjmp	.+254    	; 0x2034e <SP_CommonLPM>

00020250 <SP_ReadFuseByte>:

.section .text	
.global SP_ReadFuseByte

SP_ReadFuseByte:
	sts	NVM_ADDR0, r24              ; Load fuse byte index into NVM Address Register 0.
   20250:	80 93 c0 01 	sts	0x01C0, r24	; 0x8001c0 <__TEXT_REGION_LENGTH__+0x7001c0>
	clr	r24                         ; Prepare a zero.
   20254:	88 27       	eor	r24, r24
	sts	NVM_ADDR1, r24              ; Load zero into NVM Address Register 1.
   20256:	80 93 c1 01 	sts	0x01C1, r24	; 0x8001c1 <__TEXT_REGION_LENGTH__+0x7001c1>
	sts	NVM_ADDR2, r24              ; Load zero into NVM Address Register 2.
   2025a:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <__TEXT_REGION_LENGTH__+0x7001c2>
	ldi	r20, NVM_CMD_READ_FUSES_gc  ; Prepare NVM command in R20.
   2025e:	47 e0       	ldi	r20, 0x07	; 7
	rcall	SP_CommonCMD                ; Jump to common NVM Action code.
   20260:	66 d0       	rcall	.+204    	; 0x2032e <SP_CommonCMD>
	movw	r24, r22                    ; Move low byte to 1 byte return address.
   20262:	cb 01       	movw	r24, r22
	ret
   20264:	08 95       	ret

00020266 <SP_WriteLockBits>:

.section .text	
.global SP_WriteLockBits

SP_WriteLockBits:
	sts	NVM_DATA0, r24                  ; Load lock bits into NVM Data Register 0.
   20266:	80 93 c4 01 	sts	0x01C4, r24	; 0x8001c4 <__TEXT_REGION_LENGTH__+0x7001c4>
	ldi	r20, NVM_CMD_WRITE_LOCK_BITS_gc ; Prepare NVM command in R20.
   2026a:	48 e0       	ldi	r20, 0x08	; 8
	rjmp	SP_CommonCMD                    ; Jump to common NVM Action code.
   2026c:	60 c0       	rjmp	.+192    	; 0x2032e <SP_CommonCMD>

0002026e <SP_ReadLockBits>:

.section .text		
.global SP_ReadLockBits

SP_ReadLockBits:
	lds	r24, NVM_LOCKBITS       ; Read IO-mapped lock bits.
   2026e:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <__TEXT_REGION_LENGTH__+0x7001d0>
	ret
   20272:	08 95       	ret

00020274 <SP_EraseUserSignatureRow>:

.section .text
.global SP_EraseUserSignatureRow

SP_EraseUserSignatureRow:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   20274:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_USER_SIG_ROW_gc ; Prepare NVM command in R20.
   20276:	48 e1       	ldi	r20, 0x18	; 24
	jmp 	SP_CommonSPM                       ; Jump to common SPM code.
   20278:	0d 94 a6 03 	jmp	0x2074c	; 0x2074c <SP_CommonSPM>

0002027c <SP_WriteUserSignatureRow>:

.section .text
.global SP_WriteUserSignatureRow

SP_WriteUserSignatureRow:
	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
   2027c:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_WRITE_USER_SIG_ROW_gc  ; Prepare NVM command in R20.
   2027e:	4a e1       	ldi	r20, 0x1A	; 26
	jmp	SP_CommonSPM                        ; Jump to common SPM code.
   20280:	0d 94 a6 03 	jmp	0x2074c	; 0x2074c <SP_CommonSPM>

00020284 <SP_EraseApplicationSection>:

.section .text
.global SP_EraseApplicationSection

SP_EraseApplicationSection:
	in	r19, RAMPZ                 ; Save RAMPZ, which is restored in SP_CommonSPM.
   20284:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_APP_gc  ; Prepare NVM command in R20.
   20286:	40 e2       	ldi	r20, 0x20	; 32
	jmp	SP_CommonSPM               ; Jump to common SPM code.
   20288:	0d 94 a6 03 	jmp	0x2074c	; 0x2074c <SP_CommonSPM>

0002028c <SP_EraseApplicationPage>:

.section .text	
.global SP_EraseApplicationPage

SP_EraseApplicationPage:
	in	r19, RAMPZ                      ; Save RAMPZ, which is restored in SP_CommonSPM.
   2028c:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                      ; Load RAMPZ with the MSB of the address.
   2028e:	8b bf       	out	0x3b, r24	; 59
	movw    r24, r22                        ; Move low bytes for ZH:ZL to R25:R24
   20290:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_APP_PAGE_gc  ; Prepare NVM command in R20.
   20292:	42 e2       	ldi	r20, 0x22	; 34
	jmp	SP_CommonSPM                    ; Jump to common SPM code.
   20294:	0d 94 a6 03 	jmp	0x2074c	; 0x2074c <SP_CommonSPM>

00020298 <SP_LoadFlashWord>:

.section .text
.global SP_LoadFlashWord

SP_LoadFlashWord:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   20298:	3b b7       	in	r19, 0x3b	; 59
	movw	r0, r22                            ; Prepare flash word in R1:R0.
   2029a:	0b 01       	movw	r0, r22
	ldi	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
   2029c:	43 e2       	ldi	r20, 0x23	; 35
	jmp	SP_CommonSPM                       ; Jump to common SPM code.
   2029e:	0d 94 a6 03 	jmp	0x2074c	; 0x2074c <SP_CommonSPM>

000202a2 <SP_ReadFlashPage>:
.section .text		
.global SP_ReadFlashPage

SP_ReadFlashPage:

	in	r19, RAMPZ                   ; Save RAMPZ during assembly.
   202a2:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r22                   ; Load RAMPZ with MSB of address
   202a4:	6b bf       	out	0x3b, r22	; 59
	movw    ZL, r20                      ; Load Z with Flash address.
   202a6:	fa 01       	movw	r30, r20

	out	RAMPX, r1                    ; Load RAMPX with data pointer
   202a8:	19 be       	out	0x39, r1	; 57
	movw	XL, r24                      ; Load X with data buffer address.
   202aa:	dc 01       	movw	r26, r24

	ldi	r20, NVM_CMD_NO_OPERATION_gc ; Prepare NVM command code in R20.
   202ac:	40 e0       	ldi	r20, 0x00	; 0
	sts	NVM_CMD, r20                 ; Set NVM command to No Operation so that LPM reads Flash.
   202ae:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>

#if FLASH_PAGE_SIZE > 512
	ldi	r22, ((FLASH_PAGE_SIZE/2) >> 8) ; Load R22 with byte cont high if flash page is large.
#endif	

	ldi	r21, ((FLASH_PAGE_SIZE)&0xFF)   ; Load R21 with byte count.
   202b2:	50 e0       	ldi	r21, 0x00	; 0

000202b4 <SP_ReadFlashPage_1>:

SP_ReadFlashPage_1:
	elpm	r24, Z+                         ; Load Flash bytes into R18:r19
   202b4:	87 91       	elpm	r24, Z+
	elpm	r25, Z+
   202b6:	97 91       	elpm	r25, Z+
	st	X+, r24                         ; Write bytes to buffer.
   202b8:	8d 93       	st	X+, r24
	st	X+, r25
   202ba:	9d 93       	st	X+, r25

#if FLASH_PAGE_SIZE > 512
	subi	r21, 1                          ; Decrement word count.
	sbci	r22, 0
#else
	dec	r21                             ; Decrement word count.
   202bc:	5a 95       	dec	r21
#endif	

	brne	SP_ReadFlashPage_1              ; Repeat until byte count is zero.
   202be:	d1 f7       	brne	.-12     	; 0x202b4 <SP_ReadFlashPage_1>

	out	RAMPZ, r19
   202c0:	3b bf       	out	0x3b, r19	; 59
	ret
   202c2:	08 95       	ret

000202c4 <SP_WriteApplicationPage>:

.section .text		
.global SP_WriteApplicationPage

SP_WriteApplicationPage:
	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
   202c4:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
   202c6:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
   202c8:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_WRITE_APP_PAGE_gc   ; Prepare NVM command in R20.
   202ca:	44 e2       	ldi	r20, 0x24	; 36
	jmp	SP_CommonSPM                     ; Jump to common SPM code.
   202cc:	0d 94 a6 03 	jmp	0x2074c	; 0x2074c <SP_CommonSPM>

000202d0 <SP_EraseWriteApplicationPage>:

.section .text
.global SP_EraseWriteApplicationPage

SP_EraseWriteApplicationPage:
	in	r19, RAMPZ                            ; Save RAMPZ, which is restored in SP_CommonSPM.
   202d0:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                            ; Load RAMPZ with the MSB of the address.
   202d2:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                              ; Move low bytes of address to ZH:ZL from R23:R22
   202d4:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_WRITE_APP_PAGE_gc  ; Prepare NVM command in R20.
   202d6:	45 e2       	ldi	r20, 0x25	; 37
	jmp	SP_CommonSPM                          ; Jump to common SPM code.
   202d8:	0d 94 a6 03 	jmp	0x2074c	; 0x2074c <SP_CommonSPM>

000202dc <SP_EraseFlashBuffer>:

.section .text		
.global SP_EraseFlashBuffer

SP_EraseFlashBuffer:
	in	r19, RAMPZ                          ; Save RAMPZ, which is restored in SP_CommonSPM.
   202dc:	3b b7       	in	r19, 0x3b	; 59
	ldi	r20, NVM_CMD_ERASE_FLASH_BUFFER_gc  ; Prepare NVM command in R20.
   202de:	46 e2       	ldi	r20, 0x26	; 38
	jmp	SP_CommonSPM                        ; Jump to common SPM code.
   202e0:	0d 94 a6 03 	jmp	0x2074c	; 0x2074c <SP_CommonSPM>

000202e4 <SP_EraseBootPage>:

.section .text		
.global SP_EraseBootPage

SP_EraseBootPage:
	in	r19, RAMPZ                         ; Save RAMPZ, which is restored in SP_CommonSPM.
   202e4:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                         ; Load RAMPZ with the MSB of the address.
   202e6:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                           ; Move low bytes of address to ZH:ZL from R23:R22
   202e8:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_BOOT_PAGE_gc    ; Prepare NVM command in R20.
   202ea:	4a e2       	ldi	r20, 0x2A	; 42
	jmp	SP_CommonSPM                       ; Jump to common SPM code.
   202ec:	0d 94 a6 03 	jmp	0x2074c	; 0x2074c <SP_CommonSPM>

000202f0 <SP_WriteBootPage>:

.section .text		
.global SP_WriteBootPage

SP_WriteBootPage:
	in	r19, RAMPZ                       ; Save RAMPZ, which is restored in SP_CommonSPM.
   202f0:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                       ; Load RAMPZ with the MSB of the address.
   202f2:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                         ; Move low bytes of address to ZH:ZL from R23:R22
   202f4:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
   202f6:	4c e2       	ldi	r20, 0x2C	; 44
	jmp	SP_CommonSPM                     ; Jump to common SPM code.
   202f8:	0d 94 a6 03 	jmp	0x2074c	; 0x2074c <SP_CommonSPM>

000202fc <SP_EraseWriteBootPage>:

.section .text		
.global SP_EraseWriteBootPage

SP_EraseWriteBootPage:
	in	r19, RAMPZ                             ; Save RAMPZ, which is restored in SP_CommonSPM.
   202fc:	3b b7       	in	r19, 0x3b	; 59
	out	RAMPZ, r24                             ; Load RAMPZ with the MSB of the address.
   202fe:	8b bf       	out	0x3b, r24	; 59
	movw	r24, r22                               ; Move low bytes of address to ZH:ZL from R23:R22
   20300:	cb 01       	movw	r24, r22
	ldi	r20, NVM_CMD_ERASE_WRITE_BOOT_PAGE_gc  ; Prepare NVM command in R20.
   20302:	4d e2       	ldi	r20, 0x2D	; 45
	jmp	SP_CommonSPM                           ; Jump to common SPM code.
   20304:	0d 94 a6 03 	jmp	0x2074c	; 0x2074c <SP_CommonSPM>

00020308 <SP_ApplicationCRC>:

.section .text	
.global SP_ApplicationCRC

SP_ApplicationCRC:
	ldi	r20, NVM_CMD_APP_CRC_gc    ; Prepare NVM command in R20.
   20308:	48 e3       	ldi	r20, 0x38	; 56
	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
   2030a:	11 c0       	rjmp	.+34     	; 0x2032e <SP_CommonCMD>

0002030c <SP_BootCRC>:

.section .text
.global SP_BootCRC

SP_BootCRC:
	ldi	r20, NVM_CMD_BOOT_CRC_gc   ; Prepare NVM command in R20.
   2030c:	49 e3       	ldi	r20, 0x39	; 57
	rjmp	SP_CommonCMD               ; Jump to common NVM Action code.
   2030e:	0f c0       	rjmp	.+30     	; 0x2032e <SP_CommonCMD>

00020310 <SP_LockSPM>:

.section .text
.global SP_LockSPM

SP_LockSPM:
	ldi	r18, CCP_IOREG_gc     ; Prepare Protect IO-register signature in R18.
   20310:	28 ed       	ldi	r18, 0xD8	; 216
	sts	CCP, r18              ; Enable IO-register operation (this disables interrupts for 4 cycles).
   20312:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	ldi	r18, NVM_SPMLOCK_bm   ; Prepare bitmask for locking SPM into R18.
   20316:	21 e0       	ldi	r18, 0x01	; 1
	sts	NVM_CTRLB, r18        ; Load bitmask into NVM Control Register B, which locks SPM.
   20318:	20 93 cc 01 	sts	0x01CC, r18	; 0x8001cc <__TEXT_REGION_LENGTH__+0x7001cc>
	ret
   2031c:	08 95       	ret

0002031e <SP_WaitForSPM>:

.section .text
.global SP_WaitForSPM		

SP_WaitForSPM:
	lds	r18, NVM_STATUS     ; Load the NVM Status register.
   2031e:	20 91 cf 01 	lds	r18, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7001cf>
	sbrc	r18, NVM_NVMBUSY_bp ; Check if bit is cleared.
   20322:	27 fd       	sbrc	r18, 7
	rjmp	SP_WaitForSPM       ; Repeat check if bit is not cleared.
   20324:	fc cf       	rjmp	.-8      	; 0x2031e <SP_WaitForSPM>
	clr	r18
   20326:	22 27       	eor	r18, r18
	sts	NVM_CMD, r18        ; Clear up command register to NO_OPERATION.
   20328:	20 93 ca 01 	sts	0x01CA, r18	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	ret
   2032c:	08 95       	ret

0002032e <SP_CommonCMD>:
; ---

.section .text		

SP_CommonCMD:
	sts	NVM_CMD, r20        ; Load command into NVM Command register.
   2032e:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	ldi	r18, CCP_IOREG_gc   ; Prepare Protect IO-register signature in R18.
   20332:	28 ed       	ldi	r18, 0xD8	; 216
	ldi	r19, NVM_CMDEX_bm   ; Prepare bitmask for setting NVM Command Execute bit into R19.
   20334:	31 e0       	ldi	r19, 0x01	; 1
	sts	CCP, r18            ; Enable IO-register operation (this disables interrupts for 4 cycles).
   20336:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	sts	NVM_CTRLA, r19      ; Load bitmask into NVM Control Register A, which executes the command.
   2033a:	30 93 cb 01 	sts	0x01CB, r19	; 0x8001cb <__TEXT_REGION_LENGTH__+0x7001cb>
	lds	r22, NVM_DATA0      ; Load NVM Data Register 0 into R22.
   2033e:	60 91 c4 01 	lds	r22, 0x01C4	; 0x8001c4 <__TEXT_REGION_LENGTH__+0x7001c4>
	lds	r23, NVM_DATA1      ; Load NVM Data Register 1 into R23.
   20342:	70 91 c5 01 	lds	r23, 0x01C5	; 0x8001c5 <__TEXT_REGION_LENGTH__+0x7001c5>
	lds	r24, NVM_DATA2      ; Load NVM Data Register 2 into R24.
   20346:	80 91 c6 01 	lds	r24, 0x01C6	; 0x8001c6 <__TEXT_REGION_LENGTH__+0x7001c6>
	clr	r25                 ; Clear R25 in order to return a clean 32-bit value.
   2034a:	99 27       	eor	r25, r25
	ret
   2034c:	08 95       	ret

0002034e <SP_CommonLPM>:
; ---

.section .text		

SP_CommonLPM:
	movw	ZL, r24             ; Load index into Z.
   2034e:	fc 01       	movw	r30, r24
	sts	NVM_CMD, r20        ; Load prepared command into NVM Command register.
   20350:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm	r24,Z
   20354:	84 91       	lpm	r24, Z
	ret
   20356:	08 95       	ret

00020358 <_ZN7CSerial13RecievedblockEPhi>:
    else
    {
	    TWIC_MASTER_CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    }
    return byte;
}
   20358:	ef 92       	push	r14
   2035a:	ff 92       	push	r15
   2035c:	0f 93       	push	r16
   2035e:	1f 93       	push	r17
   20360:	cf 93       	push	r28
   20362:	df 93       	push	r29
   20364:	14 16       	cp	r1, r20
   20366:	15 06       	cpc	r1, r21
   20368:	94 f4       	brge	.+36     	; 0x2038e <_ZN7CSerial13RecievedblockEPhi+0x36>
   2036a:	8b 01       	movw	r16, r22
   2036c:	7c 01       	movw	r14, r24
   2036e:	eb 01       	movw	r28, r22
   20370:	04 0f       	add	r16, r20
   20372:	15 1f       	adc	r17, r21
   20374:	be 01       	movw	r22, r28
   20376:	c7 01       	movw	r24, r14
   20378:	0f 94 ec 01 	call	0x203d8	; 0x203d8 <_ZN7CSerial12RecievedcharERh>
   2037c:	00 97       	sbiw	r24, 0x00	; 0
   2037e:	49 f0       	breq	.+18     	; 0x20392 <_ZN7CSerial13RecievedblockEPhi+0x3a>
   20380:	21 96       	adiw	r28, 0x01	; 1
   20382:	c0 17       	cp	r28, r16
   20384:	d1 07       	cpc	r29, r17
   20386:	b1 f7       	brne	.-20     	; 0x20374 <_ZN7CSerial13RecievedblockEPhi+0x1c>
   20388:	81 e0       	ldi	r24, 0x01	; 1
   2038a:	90 e0       	ldi	r25, 0x00	; 0
   2038c:	02 c0       	rjmp	.+4      	; 0x20392 <_ZN7CSerial13RecievedblockEPhi+0x3a>
   2038e:	81 e0       	ldi	r24, 0x01	; 1
   20390:	90 e0       	ldi	r25, 0x00	; 0
   20392:	df 91       	pop	r29
   20394:	cf 91       	pop	r28
   20396:	1f 91       	pop	r17
   20398:	0f 91       	pop	r16
   2039a:	ff 90       	pop	r15
   2039c:	ef 90       	pop	r14
   2039e:	08 95       	ret

000203a0 <_ZN7CSerial13TransmitBlockEPhi>:
   203a0:	ef 92       	push	r14
   203a2:	ff 92       	push	r15
   203a4:	0f 93       	push	r16
   203a6:	1f 93       	push	r17
   203a8:	cf 93       	push	r28
   203aa:	df 93       	push	r29
   203ac:	14 16       	cp	r1, r20
   203ae:	15 06       	cpc	r1, r21
   203b0:	64 f4       	brge	.+24     	; 0x203ca <_ZN7CSerial13TransmitBlockEPhi+0x2a>
   203b2:	8b 01       	movw	r16, r22
   203b4:	7c 01       	movw	r14, r24
   203b6:	eb 01       	movw	r28, r22
   203b8:	04 0f       	add	r16, r20
   203ba:	15 1f       	adc	r17, r21
   203bc:	69 91       	ld	r22, Y+
   203be:	c7 01       	movw	r24, r14
   203c0:	0f 94 26 02 	call	0x2044c	; 0x2044c <_ZN7CSerial8SendcharEh>
   203c4:	c0 17       	cp	r28, r16
   203c6:	d1 07       	cpc	r29, r17
   203c8:	c9 f7       	brne	.-14     	; 0x203bc <_ZN7CSerial13TransmitBlockEPhi+0x1c>
   203ca:	df 91       	pop	r29
   203cc:	cf 91       	pop	r28
   203ce:	1f 91       	pop	r17
   203d0:	0f 91       	pop	r16
   203d2:	ff 90       	pop	r15
   203d4:	ef 90       	pop	r14
   203d6:	08 95       	ret

000203d8 <_ZN7CSerial12RecievedcharERh>:
   203d8:	cf 93       	push	r28
   203da:	df 93       	push	r29
   203dc:	00 d0       	rcall	.+0      	; 0x203de <_ZN7CSerial12RecievedcharERh+0x6>
   203de:	00 d0       	rcall	.+0      	; 0x203e0 <_ZN7CSerial12RecievedcharERh+0x8>
   203e0:	cd b7       	in	r28, 0x3d	; 61
   203e2:	de b7       	in	r29, 0x3e	; 62
   203e4:	8b 83       	std	Y+3, r24	; 0x03
   203e6:	9c 83       	std	Y+4, r25	; 0x04
   203e8:	6d 83       	std	Y+5, r22	; 0x05
   203ea:	7e 83       	std	Y+6, r23	; 0x06
   203ec:	19 82       	std	Y+1, r1	; 0x01
   203ee:	1a 82       	std	Y+2, r1	; 0x02
   203f0:	8b 81       	ldd	r24, Y+3	; 0x03
   203f2:	9c 81       	ldd	r25, Y+4	; 0x04
   203f4:	fc 01       	movw	r30, r24
   203f6:	80 81       	ld	r24, Z
   203f8:	91 81       	ldd	r25, Z+1	; 0x01
   203fa:	fc 01       	movw	r30, r24
   203fc:	81 81       	ldd	r24, Z+1	; 0x01
   203fe:	80 95       	com	r24
   20400:	88 1f       	adc	r24, r24
   20402:	88 27       	eor	r24, r24
   20404:	88 1f       	adc	r24, r24
   20406:	88 23       	and	r24, r24
   20408:	71 f0       	breq	.+28     	; 0x20426 <_ZN7CSerial12RecievedcharERh+0x4e>
   2040a:	89 81       	ldd	r24, Y+1	; 0x01
   2040c:	9a 81       	ldd	r25, Y+2	; 0x02
   2040e:	8c 32       	cpi	r24, 0x2C	; 44
   20410:	91 40       	sbci	r25, 0x01	; 1
   20412:	19 f4       	brne	.+6      	; 0x2041a <_ZN7CSerial12RecievedcharERh+0x42>
   20414:	80 e0       	ldi	r24, 0x00	; 0
   20416:	90 e0       	ldi	r25, 0x00	; 0
   20418:	13 c0       	rjmp	.+38     	; 0x20440 <_ZN7CSerial12RecievedcharERh+0x68>
   2041a:	89 81       	ldd	r24, Y+1	; 0x01
   2041c:	9a 81       	ldd	r25, Y+2	; 0x02
   2041e:	01 96       	adiw	r24, 0x01	; 1
   20420:	89 83       	std	Y+1, r24	; 0x01
   20422:	9a 83       	std	Y+2, r25	; 0x02
   20424:	e5 cf       	rjmp	.-54     	; 0x203f0 <_ZN7CSerial12RecievedcharERh+0x18>
   20426:	8b 81       	ldd	r24, Y+3	; 0x03
   20428:	9c 81       	ldd	r25, Y+4	; 0x04
   2042a:	fc 01       	movw	r30, r24
   2042c:	80 81       	ld	r24, Z
   2042e:	91 81       	ldd	r25, Z+1	; 0x01
   20430:	fc 01       	movw	r30, r24
   20432:	20 81       	ld	r18, Z
   20434:	8d 81       	ldd	r24, Y+5	; 0x05
   20436:	9e 81       	ldd	r25, Y+6	; 0x06
   20438:	fc 01       	movw	r30, r24
   2043a:	20 83       	st	Z, r18
   2043c:	81 e0       	ldi	r24, 0x01	; 1
   2043e:	90 e0       	ldi	r25, 0x00	; 0
   20440:	26 96       	adiw	r28, 0x06	; 6
   20442:	cd bf       	out	0x3d, r28	; 61
   20444:	de bf       	out	0x3e, r29	; 62
   20446:	df 91       	pop	r29
   20448:	cf 91       	pop	r28
   2044a:	08 95       	ret

0002044c <_ZN7CSerial8SendcharEh>:
   2044c:	dc 01       	movw	r26, r24
   2044e:	ed 91       	ld	r30, X+
   20450:	fc 91       	ld	r31, X
   20452:	81 81       	ldd	r24, Z+1	; 0x01
   20454:	85 ff       	sbrs	r24, 5
   20456:	fd cf       	rjmp	.-6      	; 0x20452 <_ZN7CSerial8SendcharEh+0x6>
   20458:	60 83       	st	Z, r22
   2045a:	08 95       	ret

0002045c <_ZN4CPin5OnPinEv>:
   2045c:	dc 01       	movw	r26, r24
   2045e:	ed 91       	ld	r30, X+
   20460:	fc 91       	ld	r31, X
   20462:	11 97       	sbiw	r26, 0x01	; 1
   20464:	20 85       	ldd	r18, Z+8	; 0x08
   20466:	30 e0       	ldi	r19, 0x00	; 0
   20468:	12 96       	adiw	r26, 0x02	; 2
   2046a:	8d 91       	ld	r24, X+
   2046c:	9c 91       	ld	r25, X
   2046e:	13 97       	sbiw	r26, 0x03	; 3
   20470:	28 23       	and	r18, r24
   20472:	39 23       	and	r19, r25
   20474:	81 e0       	ldi	r24, 0x01	; 1
   20476:	23 2b       	or	r18, r19
   20478:	09 f4       	brne	.+2      	; 0x2047c <_ZN4CPin5OnPinEv+0x20>
   2047a:	80 e0       	ldi	r24, 0x00	; 0
   2047c:	08 95       	ret

0002047e <_Z8exitbootv>:
    

extern "C"{extern void CCP_RST( void );}
void exitboot();

void exitboot(){ void (*gotozero)() = 0x0000; EIND = 0x00; gotozero(); }
   2047e:	1c be       	out	0x3c, r1	; 60
   20480:	e0 e0       	ldi	r30, 0x00	; 0
   20482:	f0 e0       	ldi	r31, 0x00	; 0
   20484:	19 95       	eicall
   20486:	08 95       	ret

00020488 <main>:

 int main(void) 
{   
   20488:	cf 93       	push	r28
   2048a:	df 93       	push	r29
   2048c:	00 d0       	rcall	.+0      	; 0x2048e <main+0x6>
   2048e:	1f 92       	push	r1
   20490:	cd b7       	in	r28, 0x3d	; 61
   20492:	de b7       	in	r29, 0x3e	; 62
class CCpu
{
     public:
     CCpu(){
	 //----------------InitCPU
	 OSC_CTRL = (1<<OSC_RC32MEN_bp);//разрешаем работу внутреннего тактового генератора 32MHz
   20494:	82 e0       	ldi	r24, 0x02	; 2
   20496:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
	 while(!(OSC_STATUS & (1<<OSC_RC32MRDY_bp))); // Ожидание готовности внутреннего тактового генератора 32MHz;
   2049a:	e1 e5       	ldi	r30, 0x51	; 81
   2049c:	f0 e0       	ldi	r31, 0x00	; 0
   2049e:	80 81       	ld	r24, Z
   204a0:	81 ff       	sbrs	r24, 1
   204a2:	fd cf       	rjmp	.-6      	; 0x2049e <main+0x16>
	 CCP = 0xD8; //Разрешение записи в защищённый регистр
   204a4:	28 ed       	ldi	r18, 0xD8	; 216
   204a6:	24 bf       	out	0x34, r18	; 52
	 CLK_CTRL = 1;
   204a8:	81 e0       	ldi	r24, 0x01	; 1
   204aa:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
class CInterrupt
{
    public:
	CInterrupt(){}
	CInterrupt(int usesection){
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm ;// активация контроллера прерываний 10 bytes PM
   204ae:	e0 ea       	ldi	r30, 0xA0	; 160
   204b0:	f0 e0       	ldi	r31, 0x00	; 0
   204b2:	92 81       	ldd	r25, Z+2	; 0x02
   204b4:	97 60       	ori	r25, 0x07	; 7
   204b6:	92 83       	std	Z+2, r25	; 0x02
	if(usesection == Boot)
	{
	      CCP = CCP_IOREG_gc; //Разрешение записи в защищённый регистр
   204b8:	24 bf       	out	0x34, r18	; 52
	      PMIC.CTRL |= PMIC_IVSEL_bm;  // активация таблицы прерываний загрузочного сектора
   204ba:	92 81       	ldd	r25, Z+2	; 0x02
   204bc:	90 64       	ori	r25, 0x40	; 64
   204be:	92 83       	std	Z+2, r25	; 0x02

       CPin(PORT_t *port,int pinnum,int direct){
	   portn = port;
	   pin = pinnum;
	   if(direct)
	   port->DIRSET = pinnum;
   204c0:	e0 e2       	ldi	r30, 0x20	; 32
   204c2:	f7 e0       	ldi	r31, 0x07	; 7
   204c4:	81 83       	std	Z+1, r24	; 0x01
     int pin;
  public: 
      

       CPin(PORT_t *port,int pinnum,int direct){
	   portn = port;
   204c6:	e9 83       	std	Y+1, r30	; 0x01
   204c8:	fa 83       	std	Y+2, r31	; 0x02
	   pin = pinnum;
   204ca:	20 e2       	ldi	r18, 0x20	; 32
   204cc:	30 e0       	ldi	r19, 0x00	; 0
   204ce:	2b 83       	std	Y+3, r18	; 0x03
   204d0:	3c 83       	std	Y+4, r19	; 0x04
	CSerial(int rate,int device)
	{
		if(device == microe793)
		{
			port = &USARTC0;//port C0 is used
			if(rate == bdrate19200 || rate == bdrate200000){USARTC0_BAUDCTRLB = 0;USARTC0_BAUDCTRLA = rate;}
   204d2:	10 92 a7 08 	sts	0x08A7, r1	; 0x8008a7 <__TEXT_REGION_LENGTH__+0x7008a7>
   204d6:	99 e0       	ldi	r25, 0x09	; 9
   204d8:	90 93 a6 08 	sts	0x08A6, r25	; 0x8008a6 <__TEXT_REGION_LENGTH__+0x7008a6>
			if(rate == bdrate115200){USARTC0_BAUDCTRLB = 208; USARTC0_BAUDCTRLA = rate;}
			
			USARTC0_CTRLA = USART_RXCINTLVL_MED_gc; //подключение прерываний
   204dc:	90 e2       	ldi	r25, 0x20	; 32
   204de:	90 93 a3 08 	sts	0x08A3, r25	; 0x8008a3 <__TEXT_REGION_LENGTH__+0x7008a3>
			USARTC0_CTRLC = USART_CHSIZE_8BIT_gc; //8 data bits, no parity and 1 stop bit
   204e2:	93 e0       	ldi	r25, 0x03	; 3
   204e4:	90 93 a5 08 	sts	0x08A5, r25	; 0x8008a5 <__TEXT_REGION_LENGTH__+0x7008a5>
			USARTC0_CTRLB = USART_TXEN_bm | USART_RXEN_bm; //Включение приема передатчика
   204e8:	98 e1       	ldi	r25, 0x18	; 24
   204ea:	90 93 a4 08 	sts	0x08A4, r25	; 0x8008a4 <__TEXT_REGION_LENGTH__+0x7008a4>
			PORTC.DIRSET = PIN3_bm;  // настройка ноги 3 порта С контроллера Xmega на выход!для передачи данных в микросхему Uart
   204ee:	98 e0       	ldi	r25, 0x08	; 8
   204f0:	90 93 41 06 	sts	0x0641, r25	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>

public:
    CTwi(){}
	CTwi(int speed){
	//----------------InitTWI
	TWIC.CTRL = 0;
   204f4:	10 92 80 04 	sts	0x0480, r1	; 0x800480 <__TEXT_REGION_LENGTH__+0x700480>
	TWIC_MASTER_BAUD=speed;// При 32 Мгц, на 100кГц = 155(0x9B)
   204f8:	2b e9       	ldi	r18, 0x9B	; 155
   204fa:	20 93 85 04 	sts	0x0485, r18	; 0x800485 <__TEXT_REGION_LENGTH__+0x700485>
	TWIC_MASTER_CTRLA=TWI_MASTER_ENABLE_bm; //enable master
   204fe:	90 93 81 04 	sts	0x0481, r25	; 0x800481 <__TEXT_REGION_LENGTH__+0x700481>
	TWIC_MASTER_CTRLB=0x00; //disable Inactive Bus Timeout, disable QCEN and SMEN
   20502:	10 92 82 04 	sts	0x0482, r1	; 0x800482 <__TEXT_REGION_LENGTH__+0x700482>
	TWIC_MASTER_CTRLC=0x00; //send ACK and NOACT initially
   20506:	10 92 83 04 	sts	0x0483, r1	; 0x800483 <__TEXT_REGION_LENGTH__+0x700483>
	TWIC_MASTER_STATUS=TWI_MASTER_RIF_bm|TWI_MASTER_WIF_bm|TWI_MASTER_ARBLOST_bm|TWI_MASTER_BUSERR_bm|TWI_MASTER_BUSSTATE0_bm; //initially clear all flags and select bus state as IDLE
   2050a:	9d ec       	ldi	r25, 0xCD	; 205
   2050c:	90 93 84 04 	sts	0x0484, r25	; 0x800484 <__TEXT_REGION_LENGTH__+0x700484>
	   bool OnPin();                       // 80 bytes PM
};

 void CPin::outset()
{
    portn->OUTSET = pin;
   20510:	85 83       	std	Z+5, r24	; 0x05
}

void CPin::PullDown(int numPin)
{
    if(numPin == 5)
    portn->PIN5CTRL = PORT_OPC_PULLDOWN_gc;
   20512:	e9 81       	ldd	r30, Y+1	; 0x01
   20514:	fa 81       	ldd	r31, Y+2	; 0x02
   20516:	80 e1       	ldi	r24, 0x10	; 16
   20518:	85 8b       	std	Z+21, r24	; 0x15
	void disable();
};

void CInterrupt::enable()
{
     sei();
   2051a:	78 94       	sei
}


void CPin::outclr()
{
    portn->OUTCLR = pin; 
   2051c:	0f 2e       	mov	r0, r31
   2051e:	f0 e2       	ldi	r31, 0x20	; 32
   20520:	ef 2e       	mov	r14, r31
   20522:	f7 e0       	ldi	r31, 0x07	; 7
   20524:	ff 2e       	mov	r15, r31
   20526:	f0 2d       	mov	r31, r0
   20528:	11 e0       	ldi	r17, 0x01	; 1
             
   inter.enable();
   
    while (1) 
    { 	 
	    if(pin5portK.OnPin()) // || Onboot
   2052a:	ce 01       	movw	r24, r28
   2052c:	01 96       	adiw	r24, 0x01	; 1
   2052e:	0f 94 2e 02 	call	0x2045c	; 0x2045c <_ZN4CPin5OnPinEv>
   20532:	81 11       	cpse	r24, r1
   20534:	fa cf       	rjmp	.-12     	; 0x2052a <main+0xa2>
   20536:	f7 01       	movw	r30, r14
   20538:	16 83       	std	Z+6, r17	; 0x06
		    Onboot = true;					
	    }
	    else
	    {
		    pin0portK.outclr();
		    exitboot();
   2053a:	0f 94 3f 02 	call	0x2047e	; 0x2047e <_Z8exitbootv>
   2053e:	f5 cf       	rjmp	.-22     	; 0x2052a <main+0xa2>

00020540 <__vector_25>:
	    }
    }
}

ISR(USARTC0_RXC_vect)
{
   20540:	1f 92       	push	r1
   20542:	0f 92       	push	r0
   20544:	0f b6       	in	r0, 0x3f	; 63
   20546:	0f 92       	push	r0
   20548:	11 24       	eor	r1, r1
   2054a:	08 b6       	in	r0, 0x38	; 56
   2054c:	0f 92       	push	r0
   2054e:	18 be       	out	0x38, r1	; 56
   20550:	09 b6       	in	r0, 0x39	; 57
   20552:	0f 92       	push	r0
   20554:	19 be       	out	0x39, r1	; 57
   20556:	0a b6       	in	r0, 0x3a	; 58
   20558:	0f 92       	push	r0
   2055a:	1a be       	out	0x3a, r1	; 58
   2055c:	0b b6       	in	r0, 0x3b	; 59
   2055e:	0f 92       	push	r0
   20560:	1b be       	out	0x3b, r1	; 59
   20562:	8f 92       	push	r8
   20564:	9f 92       	push	r9
   20566:	af 92       	push	r10
   20568:	bf 92       	push	r11
   2056a:	cf 92       	push	r12
   2056c:	df 92       	push	r13
   2056e:	ef 92       	push	r14
   20570:	ff 92       	push	r15
   20572:	0f 93       	push	r16
   20574:	1f 93       	push	r17
   20576:	2f 93       	push	r18
   20578:	3f 93       	push	r19
   2057a:	4f 93       	push	r20
   2057c:	5f 93       	push	r21
   2057e:	6f 93       	push	r22
   20580:	7f 93       	push	r23
   20582:	8f 93       	push	r24
   20584:	9f 93       	push	r25
   20586:	af 93       	push	r26
   20588:	bf 93       	push	r27
   2058a:	ef 93       	push	r30
   2058c:	ff 93       	push	r31
   2058e:	cf 93       	push	r28
   20590:	df 93       	push	r29
   20592:	cd b7       	in	r28, 0x3d	; 61
   20594:	de b7       	in	r29, 0x3e	; 62
   20596:	c8 51       	subi	r28, 0x18	; 24
   20598:	d2 40       	sbci	r29, 0x02	; 2
   2059a:	cd bf       	out	0x3d, r28	; 61
   2059c:	de bf       	out	0x3e, r29	; 62
	USART_t * port;
	public:
	CSerial(){}
	CSerial(USART_t * port_t)
	{
		port = port_t;
   2059e:	80 ea       	ldi	r24, 0xA0	; 160
   205a0:	98 e0       	ldi	r25, 0x08	; 8
   205a2:	89 83       	std	Y+1, r24	; 0x01
   205a4:	9a 83       	std	Y+2, r25	; 0x02

	CSerial       uart(&USARTC0);
	CTwi          twi;
	
	unsigned char block[530] = { 0 };
   205a6:	be 01       	movw	r22, r28
   205a8:	6d 5f       	subi	r22, 0xFD	; 253
   205aa:	7f 4f       	sbci	r23, 0xFF	; 255
   205ac:	82 e1       	ldi	r24, 0x12	; 18
   205ae:	92 e0       	ldi	r25, 0x02	; 2
   205b0:	fb 01       	movw	r30, r22
   205b2:	9c 01       	movw	r18, r24
   205b4:	11 92       	st	Z+, r1
   205b6:	21 50       	subi	r18, 0x01	; 1
   205b8:	30 40       	sbci	r19, 0x00	; 0
   205ba:	e1 f7       	brne	.-8      	; 0x205b4 <__vector_25+0x74>
	unsigned char answerFlash[] = { 0xff,0x02,0x04,0x0A };
   205bc:	8f ef       	ldi	r24, 0xFF	; 255
   205be:	cb 5e       	subi	r28, 0xEB	; 235
   205c0:	dd 4f       	sbci	r29, 0xFD	; 253
   205c2:	88 83       	st	Y, r24
   205c4:	c5 51       	subi	r28, 0x15	; 21
   205c6:	d2 40       	sbci	r29, 0x02	; 2
   205c8:	82 e0       	ldi	r24, 0x02	; 2
   205ca:	ca 5e       	subi	r28, 0xEA	; 234
   205cc:	dd 4f       	sbci	r29, 0xFD	; 253
   205ce:	88 83       	st	Y, r24
   205d0:	c6 51       	subi	r28, 0x16	; 22
   205d2:	d2 40       	sbci	r29, 0x02	; 2
   205d4:	84 e0       	ldi	r24, 0x04	; 4
   205d6:	c9 5e       	subi	r28, 0xE9	; 233
   205d8:	dd 4f       	sbci	r29, 0xFD	; 253
   205da:	88 83       	st	Y, r24
   205dc:	c7 51       	subi	r28, 0x17	; 23
   205de:	d2 40       	sbci	r29, 0x02	; 2
   205e0:	8a e0       	ldi	r24, 0x0A	; 10
   205e2:	c8 5e       	subi	r28, 0xE8	; 232
   205e4:	dd 4f       	sbci	r29, 0xFD	; 253
   205e6:	88 83       	st	Y, r24
   205e8:	c8 51       	subi	r28, 0x18	; 24
   205ea:	d2 40       	sbci	r29, 0x02	; 2

	uart.Recievedblock(block,sizeof(block));
   205ec:	42 e1       	ldi	r20, 0x12	; 18
   205ee:	52 e0       	ldi	r21, 0x02	; 2
   205f0:	ce 01       	movw	r24, r28
   205f2:	01 96       	adiw	r24, 0x01	; 1
   205f4:	0f 94 ac 01 	call	0x20358	; 0x20358 <_ZN7CSerial13RecievedblockEPhi>
	
	if ( block[3] == WRITE_)
   205f8:	8e 81       	ldd	r24, Y+6	; 0x06
   205fa:	83 30       	cpi	r24, 0x03	; 3
   205fc:	e9 f5       	brne	.+122    	; 0x20678 <__vector_25+0x138>
	{
		unsigned long addres_page = (int)block[6] - 1;
   205fe:	89 84       	ldd	r8, Y+9	; 0x09
   20600:	91 2c       	mov	r9, r1
   20602:	31 e0       	ldi	r19, 0x01	; 1
   20604:	83 1a       	sub	r8, r19
   20606:	91 08       	sbc	r9, r1
   20608:	09 2c       	mov	r0, r9
   2060a:	00 0c       	add	r0, r0
   2060c:	aa 08       	sbc	r10, r10
   2060e:	bb 08       	sbc	r11, r11
		addres_page = addres_page * 512;
   20610:	07 2e       	mov	r0, r23
   20612:	79 e0       	ldi	r23, 0x09	; 9
   20614:	88 0c       	add	r8, r8
   20616:	99 1c       	adc	r9, r9
   20618:	aa 1c       	adc	r10, r10
   2061a:	bb 1c       	adc	r11, r11
   2061c:	7a 95       	dec	r23
   2061e:	d1 f7       	brne	.-12     	; 0x20614 <__vector_25+0xd4>
   20620:	70 2d       	mov	r23, r0

	    if(NVM.CTRLB & NVM_SPMLOCK_bm) { CCP_RST(); }
   20622:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <__TEXT_REGION_LENGTH__+0x7001cc>
   20626:	80 ff       	sbrs	r24, 0
   20628:	46 c0       	rjmp	.+140    	; 0x206b6 <__vector_25+0x176>
   2062a:	0f 94 11 01 	call	0x20222	; 0x20222 <CCP_RST>
   2062e:	43 c0       	rjmp	.+134    	; 0x206b6 <__vector_25+0x176>
			return;
		
		for(int x=0;x<APP_SECTION_PAGE_SIZE;x+=2)
		{
			uint16_t word;
			word = (uint8_t) block[x + 8];          //low
   20630:	f6 01       	movw	r30, r12
   20632:	00 81       	ld	r16, Z
			word |= (uint8_t) block[x + 9]<<8;      //hi
   20634:	81 81       	ldd	r24, Z+1	; 0x01
   20636:	10 e0       	ldi	r17, 0x00	; 0
   20638:	18 2b       	or	r17, r24
			SP_WaitForSPM();
   2063a:	0f 94 8f 01 	call	0x2031e	; 0x2031e <SP_WaitForSPM>
			SP_LoadFlashWord(x, word);
   2063e:	b8 01       	movw	r22, r16
   20640:	c7 01       	movw	r24, r14
   20642:	0f 94 4c 01 	call	0x20298	; 0x20298 <SP_LoadFlashWord>
	    if(NVM.CTRLB & NVM_SPMLOCK_bm) { CCP_RST(); }

		if(addres_page >= APP_END)
			return;
		
		for(int x=0;x<APP_SECTION_PAGE_SIZE;x+=2)
   20646:	f2 e0       	ldi	r31, 0x02	; 2
   20648:	ef 0e       	add	r14, r31
   2064a:	f1 1c       	adc	r15, r1
   2064c:	22 e0       	ldi	r18, 0x02	; 2
   2064e:	c2 0e       	add	r12, r18
   20650:	d1 1c       	adc	r13, r1
   20652:	e1 14       	cp	r14, r1
   20654:	32 e0       	ldi	r19, 0x02	; 2
   20656:	f3 06       	cpc	r15, r19
   20658:	59 f7       	brne	.-42     	; 0x20630 <__vector_25+0xf0>
			word = (uint8_t) block[x + 8];          //low
			word |= (uint8_t) block[x + 9]<<8;      //hi
			SP_WaitForSPM();
			SP_LoadFlashWord(x, word);
		}
		SP_WaitForSPM();
   2065a:	0f 94 8f 01 	call	0x2031e	; 0x2031e <SP_WaitForSPM>
		SP_EraseWriteApplicationPage(addres_page);
   2065e:	c5 01       	movw	r24, r10
   20660:	b4 01       	movw	r22, r8
   20662:	0f 94 68 01 	call	0x202d0	; 0x202d0 <SP_EraseWriteApplicationPage>

		uart.TransmitBlock(answerFlash,sizeof(answerFlash));
   20666:	44 e0       	ldi	r20, 0x04	; 4
   20668:	50 e0       	ldi	r21, 0x00	; 0
   2066a:	be 01       	movw	r22, r28
   2066c:	6b 5e       	subi	r22, 0xEB	; 235
   2066e:	7d 4f       	sbci	r23, 0xFD	; 253
   20670:	ce 01       	movw	r24, r28
   20672:	01 96       	adiw	r24, 0x01	; 1
   20674:	0f 94 d0 01 	call	0x203a0	; 0x203a0 <_ZN7CSerial13TransmitBlockEPhi>
	}


	if ( block[3] == TEST_ && block[4] == TEST_ ){ uart.TransmitBlock(block,8); }
   20678:	8e 81       	ldd	r24, Y+6	; 0x06
   2067a:	85 35       	cpi	r24, 0x55	; 85
   2067c:	61 f4       	brne	.+24     	; 0x20696 <__vector_25+0x156>
   2067e:	8f 81       	ldd	r24, Y+7	; 0x07
   20680:	85 35       	cpi	r24, 0x55	; 85
   20682:	31 f5       	brne	.+76     	; 0x206d0 <__vector_25+0x190>
   20684:	48 e0       	ldi	r20, 0x08	; 8
   20686:	50 e0       	ldi	r21, 0x00	; 0
   20688:	be 01       	movw	r22, r28
   2068a:	6d 5f       	subi	r22, 0xFD	; 253
   2068c:	7f 4f       	sbci	r23, 0xFF	; 255
   2068e:	ce 01       	movw	r24, r28
   20690:	01 96       	adiw	r24, 0x01	; 1
   20692:	0f 94 d0 01 	call	0x203a0	; 0x203a0 <_ZN7CSerial13TransmitBlockEPhi>

	if ( block[3] == SET_TIME && block[4] == SET_TIME) { uart.TransmitBlock(block,1); }
   20696:	8e 81       	ldd	r24, Y+6	; 0x06
   20698:	87 30       	cpi	r24, 0x07	; 7
   2069a:	d1 f4       	brne	.+52     	; 0x206d0 <__vector_25+0x190>
   2069c:	8f 81       	ldd	r24, Y+7	; 0x07
   2069e:	87 30       	cpi	r24, 0x07	; 7
   206a0:	b9 f4       	brne	.+46     	; 0x206d0 <__vector_25+0x190>
   206a2:	41 e0       	ldi	r20, 0x01	; 1
   206a4:	50 e0       	ldi	r21, 0x00	; 0
   206a6:	be 01       	movw	r22, r28
   206a8:	6d 5f       	subi	r22, 0xFD	; 253
   206aa:	7f 4f       	sbci	r23, 0xFF	; 255
   206ac:	ce 01       	movw	r24, r28
   206ae:	01 96       	adiw	r24, 0x01	; 1
   206b0:	0f 94 d0 01 	call	0x203a0	; 0x203a0 <_ZN7CSerial13TransmitBlockEPhi>
   206b4:	0d c0       	rjmp	.+26     	; 0x206d0 <__vector_25+0x190>
		unsigned long addres_page = (int)block[6] - 1;
		addres_page = addres_page * 512;

	    if(NVM.CTRLB & NVM_SPMLOCK_bm) { CCP_RST(); }

		if(addres_page >= APP_END)
   206b6:	81 14       	cp	r8, r1
   206b8:	91 04       	cpc	r9, r1
   206ba:	82 e0       	ldi	r24, 0x02	; 2
   206bc:	a8 06       	cpc	r10, r24
   206be:	b1 04       	cpc	r11, r1
   206c0:	38 f4       	brcc	.+14     	; 0x206d0 <__vector_25+0x190>
   206c2:	6e 01       	movw	r12, r28
   206c4:	eb e0       	ldi	r30, 0x0B	; 11
   206c6:	ce 0e       	add	r12, r30
   206c8:	d1 1c       	adc	r13, r1
   206ca:	e1 2c       	mov	r14, r1
   206cc:	f1 2c       	mov	r15, r1
   206ce:	b0 cf       	rjmp	.-160    	; 0x20630 <__vector_25+0xf0>
	if ( block[3] == TEST_ && block[4] == TEST_ ){ uart.TransmitBlock(block,8); }

	if ( block[3] == SET_TIME && block[4] == SET_TIME) { uart.TransmitBlock(block,1); }
	
	return;	
}
   206d0:	c8 5e       	subi	r28, 0xE8	; 232
   206d2:	dd 4f       	sbci	r29, 0xFD	; 253
   206d4:	cd bf       	out	0x3d, r28	; 61
   206d6:	de bf       	out	0x3e, r29	; 62
   206d8:	df 91       	pop	r29
   206da:	cf 91       	pop	r28
   206dc:	ff 91       	pop	r31
   206de:	ef 91       	pop	r30
   206e0:	bf 91       	pop	r27
   206e2:	af 91       	pop	r26
   206e4:	9f 91       	pop	r25
   206e6:	8f 91       	pop	r24
   206e8:	7f 91       	pop	r23
   206ea:	6f 91       	pop	r22
   206ec:	5f 91       	pop	r21
   206ee:	4f 91       	pop	r20
   206f0:	3f 91       	pop	r19
   206f2:	2f 91       	pop	r18
   206f4:	1f 91       	pop	r17
   206f6:	0f 91       	pop	r16
   206f8:	ff 90       	pop	r15
   206fa:	ef 90       	pop	r14
   206fc:	df 90       	pop	r13
   206fe:	cf 90       	pop	r12
   20700:	bf 90       	pop	r11
   20702:	af 90       	pop	r10
   20704:	9f 90       	pop	r9
   20706:	8f 90       	pop	r8
   20708:	0f 90       	pop	r0
   2070a:	0b be       	out	0x3b, r0	; 59
   2070c:	0f 90       	pop	r0
   2070e:	0a be       	out	0x3a, r0	; 58
   20710:	0f 90       	pop	r0
   20712:	09 be       	out	0x39, r0	; 57
   20714:	0f 90       	pop	r0
   20716:	08 be       	out	0x38, r0	; 56
   20718:	0f 90       	pop	r0
   2071a:	0f be       	out	0x3f, r0	; 63
   2071c:	0f 90       	pop	r0
   2071e:	1f 90       	pop	r1
   20720:	18 95       	reti

00020722 <_exit>:
   20722:	f8 94       	cli

00020724 <__stop_program>:
   20724:	ff cf       	rjmp	.-2      	; 0x20724 <__stop_program>

Disassembly of section .BOOT:

00020726 <SP_LoadFlashPage>:
		
.section .BOOT, "ax"
.global SP_LoadFlashPage

SP_LoadFlashPage:
	clr	ZL              ; Clear low byte of Z, to indicate start of page.
   20726:	ee 27       	eor	r30, r30
	clr	ZH              ; Clear high byte of Z, to indicate start of page.
   20728:	ff 27       	eor	r31, r31

	out	RAMPX, r1       ; Clear RAMPX pointer.
   2072a:	19 be       	out	0x39, r1	; 57
	movw	XL, r24         ; Load X with data buffer address.
   2072c:	dc 01       	movw	r26, r24

	ldi 	r20, NVM_CMD_LOAD_FLASH_BUFFER_gc  ; Prepare NVM command code in R20.
   2072e:	43 e2       	ldi	r20, 0x23	; 35
	sts	NVM_CMD, r20                       ; Load it into NVM command register.
   20730:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>

#if FLASH_PAGE_SIZE > 512
	ldi	r22, ((FLASH_PAGE_SIZE/2) >> 8)
#endif

	ldi	r21, ((FLASH_PAGE_SIZE/2)&0xFF)    ; Load R21 with page word count.
   20734:	50 e0       	ldi	r21, 0x00	; 0
	ldi	r18, CCP_SPM_gc                    ; Prepare Protect SPM signature in R16.
   20736:	2d e9       	ldi	r18, 0x9D	; 157

00020738 <SP_LoadFlashPage_1>:

SP_LoadFlashPage_1:
	ld	r0, X+         ; Load low byte from buffer into R0.
   20738:	0d 90       	ld	r0, X+
	ld	r1, X+         ; Load high byte from buffer into R1.
   2073a:	1d 90       	ld	r1, X+
	sts	CCP, r18       ; Enable SPM operation (this disables interrupts for 4 cycles).
   2073c:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	spm                    ; Self-program.
   20740:	e8 95       	spm
	adiw	ZL, 2          ; Move Z to next Flash word.
   20742:	32 96       	adiw	r30, 0x02	; 2

#if FLASH_PAGE_SIZE > 512
	subi	r21, 1         ; Decrement word count.
	sbci	r22, 0
#else
	dec	r21            ; Decrement word count.
   20744:	5a 95       	dec	r21
#endif

	brne	SP_LoadFlashPage_1   ; Repeat until word cont is zero.
   20746:	c1 f7       	brne	.-16     	; 0x20738 <SP_LoadFlashPage_1>

	clr	r1                   ; Clear R1 for GCC _zero_reg_ to function properly.
   20748:	11 24       	eor	r1, r1
	ret
   2074a:	08 95       	ret

0002074c <SP_CommonSPM>:
; ---

.section .BOOT, "ax"

SP_CommonSPM:
	movw	ZL, r24          ; Load R25:R24 into Z.
   2074c:	fc 01       	movw	r30, r24
	sts	NVM_CMD, r20     ; Load prepared command into NVM Command register.
   2074e:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	ldi	r18, CCP_SPM_gc  ; Prepare Protect SPM signature in R18
   20752:	2d e9       	ldi	r18, 0x9D	; 157
	sts	CCP, r18         ; Enable SPM operation (this disables interrupts for 4 cycles).
   20754:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x700034>
	spm                      ; Self-program.
   20758:	e8 95       	spm
	clr	r1               ; Clear R1 for GCC _zero_reg_ to function properly.
   2075a:	11 24       	eor	r1, r1
	out	RAMPZ, r19       ; Restore RAMPZ register.
   2075c:	3b bf       	out	0x3b, r19	; 59
	ret
   2075e:	08 95       	ret
